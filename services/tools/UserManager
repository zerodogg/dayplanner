#!/usr/bin/perl
# UserManager
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

require 5.8.0;
use strict;
use warnings;
use Term::ReadLine;
use Term::ReadKey;
use Data::Dumper;
use IO::Socket::INET;
use File::Path qw/mkpath rmtree/;

my %Users;
my %DPServices;
my $DataDir = "./dpservices/";
$| = 1;		# Don't buffer output

# Purpose: Send a command to the daemon
# Usage: SendDaemonCommand(COMMAND);
sub SendDaemonCommand {
	my $Command = shift;
	my $SocketName = "$DataDir/adminsocket";
	# Verify socket existance
	unless (-e $SocketName) {
		die "$SocketName doesn't exist\n";
	}

	# Verify that it actually IS a socket
	unless (-S $SocketName) {
		die "$SocketName is not a socket\n";
	}

	# Open up the connection to the socket or die trying
	my $socket = IO::Socket::UNIX->new(Peer	=> $SocketName,
	                                Type	=> SOCK_STREAM,
					Timeout	=> 10 )
	    or die "Couldn't connect to $SocketName: $@\nPerhaps the services daemon isn't running?\n";
	print $socket $Command,"\n";
	my $Return = <$socket>;
	close($socket);
	chomp($Return);
	return($Return);
}

# Purpose: Load the data
# Usage: LoadData();
sub LoadData {
	unless(-e "$DataDir/users.conf") {
		die("$DataDir/users.conf does not exist\n");
	}
	%Users = do("$DataDir/users.conf");
	return(1);
}

# Purpose: Write the data
# Usage: WriteData();
sub WriteData {
	my $WriteTo;
	open($WriteTo, ">", "$DataDir/users.conf") or do {
		print "WARNING: Unable to write data to $DataDir/users.conf!\n";
		return(undef);
	};
	print $WriteTo "# Day planner services user configuration file\n";
	$Data::Dumper::Purity = 1;
	$Data::Dumper::Sortkeys = 1;
	$Data::Dumper::Indent = 1;
	print $WriteTo Data::Dumper->Dump([\%Users], ["*Users"]);
	close($WriteTo);
	DaemonReloadUsers();
}

# Purpose: Tell the daemon to reload its user list
# Usage: DaemonReloadUsers();
sub DaemonReloadUsers {
	print "Telling the daemon to reload the data...";
	my $Reply = SendDaemonCommand("RELOAD_USERLIST");
	if($Reply eq "DONE") {
		print "done\n";
	} else {
		if($Reply eq "REFUSED") {
			print "failed. Permission denied\n";
		} else {
			print "failed, replied $Reply\n";
		}
	}
}

# Purpose: Display the uptime of the daemon
# Usage: DaemonUptime();
sub DaemonUptime {
	my $Reply = SendDaemonCommand("UPTIME");
	if($Reply eq "REFUSED") {
		print "Permission denied.\n";
	} else {
		print "Uptime: $Reply\n";
	}
	WaitContinue();
}

# Purpose: Print prompt, get input and validate the input
# Usage: my $Input = GetInput("PROMPT", "VALID_INPUT");
# 	VALID_INPUT can be [NUMERIC] for nunmeric, a list of characters (not seperated)
# 	or simply "" for "anything as long as it's not empty"
sub GetInput ($$) {
	my ($Message, $Commands) = @_;
	while (1) {
		print "$Message";
		my $Input = <STDIN>;
		chomp($Input);
		if(length($Input) and $Input =~ /\S/) {
			if(length($Commands)) {
				if ($Commands eq '[NUMERIC]') {
					if ($Input =~ /^\d+$/) {
						return($Input);
					} else {
						print "Kun tall er tillatt\n";
					}
				} else {
					foreach(split(//, $Commands)) {
						if($Input =~ /^$_$/i) {
							return($Input);
						}
					}
					print "Invalid response\n";
				}
			} else {
				return($Input);
			}
		}
	}
}

# Purpose: Get a password
# Usage: GetPassword();
sub GetPassword {
	print "Password: ";
	ReadMode(2);
	my $key = <STDIN>;
	ReadMode(0);
	print "\n";
	chomp($key);
	return($key);
}

# Purpose: Add a user
# Usage: AddUser();
sub AddUser {
	system("clear");
	print "Adding a user\n\n";
	my $Username = GetInput("Username: ", "");
	while(defined($Users{$Username})) {
		print " That user already exists\n";
		$Username = GetInput("Username: ", "");
	}
	my $Password = GetInput("Password: ", "");
	my $Encrypted = GetInput("Should the users data be treated as encrypted? [YN] ", "yn");
	my $GenHTML = 0;
	unless($Encrypted =~ /y/i) {
		$GenHTML = GetInput("Does the user want HTML generated? [YN] ", "yn");
	} else {
		print "Warning: encryption is NOT implemented\n";
	}
	print "\n";
	my $Language = GetInput("Language: ", "");
	my $Level = SetUserLevel();
	$| = 1;
	print "Adding...";
	$Users{$Username}{password} = $Password;
	$Users{$Username}{level} = $Level;
	$Users{$Username}{settings}{Encrypted} = $Encrypted =~ /y/i ? 1 : 0;
	$Users{$Username}{settings}{GenHTML} = $GenHTML =~ /y/ ? 1 : 0;
	$Users{$Username}{settings}{language} = $Language;
	unless (-d "$DataDir/$Username/") {
		mkpath("$DataDir/$Username/") or warn("FAILED to mkpath($DataDir/$Username/): $!\n");
	}
	print "done\n";
	WriteData();
	WaitContinue();
}

# Purpose: Display formatted user level information
# Usage: UserLevelInfo(LEVEL, STATE, INFORMATION);
sub UserLevelInfo {
	printf "%-2s %-15s %s\n", $_[0], $_[1], $_[2];

}

# Purpose: Set the user level of a user
# Usage: $Level = SetUserLevel();
sub SetUserLevel {
	print "User levels:\n";
	UserLevelInfo(0, "EXPIRED", "Account expired - no access");
	UserLevelInfo(1, "EXPIRED", "Account expired - read only access");
	UserLevelInfo(2, "ACTIVE", "Account active - read/write access");
	UserLevelInfo(3, "ACTIVE", "Account active - read/write access");
	UserLevelInfo(4, "ADMIN", "Account is an admin - read/write access plus admin commands");
	my $Level = GetInput("User level: [01234] ", "01234");
	return($Level);
}

# Purpose: Get a valid user name present in the DB
# Usage: $Name = GetValidUsername();
sub GetValidUsername {
	while(1) {
		my $Username = GetInput("Username: ", "");
		if(defined($Users{$Username})) {
			return($Username);
		}
		print "No user with that username exists\n";
	}
}

# Purpose: Get information about a user
# Usage: GetUserInfo();
sub GetUserInfo {
	system("clear");
	print "Which user do you want to view information about?\n";
	my $User = GetValidUsername();
	$Data::Dumper::Purity = 1;
	$Data::Dumper::Sortkeys = 1;
	$Data::Dumper::Indent = 1;
	my $Hashref = $Users{$User}{settings};
	print Data::Dumper->Dump([$Hashref], ["*current settings"]);
	WaitContinue();
	return(1);
}

# Purpose: Change settings for a user
# Usage: ChangeUserSettings();
sub ChangeUserSettings {
	system("clear");
	print "Which user do you want to change settings for?\n";
	my $User = GetValidUsername();
	$Data::Dumper::Purity = 1;
	$Data::Dumper::Sortkeys = 1;
	$Data::Dumper::Indent = 1;
	my $Hashref = $Users{$User}{settings};
	print Data::Dumper->Dump([$Hashref], ["*current settings"]);
	while(1) {
		my $ChangeSetting = GetInput("Which setting do you want to set? ", "");
		if(defined($Users{$User}{settings}{$ChangeSetting})) {
				print "Current value: $ChangeSetting=$Users{$User}{settings}{$ChangeSetting}\n";
			} else {
				print "Current value: $ChangeSetting=NOT_SET\n";
			}
		my $ChangeTo = GetInput("What do you want to change it to? ", "");
		print "Will set the following setting:\n$ChangeSetting=$ChangeTo\n";
		my $OK = GetInput("OK? ", "YN");
		if($OK =~ /y/i) {
			$Users{$User}{settings}{$ChangeSetting} = $ChangeTo;
		} else {
			print "Change cancelled\n";
		}
		WriteData();
		WaitContinue();
		return(1);
	}
}

# Purpose: Change the level of a user
# Usage: ChangeUserLevel();
sub ChangeUserLevel {
	system("clear");
	my $User = GetValidUsername();
	my $Level = SetUserLevel();
	$Users{$User}{level} = $Level;
	print "User level of $User set to $Level\n";
	WriteData();
	WaitContinue();
}

# Purpose: Delete a user
# Usage: DeleteUser();
sub DeleteUser {
	system("clear");
	print "Which user do you want to delete?\n";
	my $User = GetValidUsername();
	delete($Users{$User});
	print "User deleted. The data directory for this user is still left intact!\n";
	WriteData();
	WaitContinue();
}

# Purpose: Print nicely formatted user list info
# Usage: PrintUserList(USERNAME, LEVEL, ACCESS);
sub PrintUserList {
	printf "%-20s %-20s %s\n", $_[0], $_[1], $_[2];
}

# Purpose: Wait until the user presses enter
# Usage: WaitContinue();
sub WaitContinue {
	$| = 1;
	print "Press enter to continue";
	<STDIN>;
}

# Purpose: Print the user list
# Usage: UserList();
sub UserList {
	system("clear");
	PrintUserList("Username:", "Level:", "Access:");
	foreach my $User (sort(keys(%Users))) {
		my $Level = $Users{$User}{level};
		my $LevelInfo;
		my $Access;
		if($Level == 0) {
			$LevelInfo = "$Level (EXPIRED)";
			$Access = "none";
		} elsif($Level == 1) {
			$LevelInfo = "$Level (EXPIRED)";
			$Access = "ro";
		} elsif($Level == 2 or $Level == 3) {
			$LevelInfo = "$Level (ACTIVE)";
			$Access = "rw";
		} elsif($Level == 4) {
			$LevelInfo = "$Level (ADMIN)";
			$Access = "rw/admin";
		} else {
			$LevelInfo = "$Level (UNKNOWN)";
			$Access = "UNKNOWN";
		}
		PrintUserList($User, $LevelInfo, $Access);
	}
	print "\n";
	WaitContinue();
}

# Purpose: Display the main menu. Also takes care of calling LoadData(); and WriteData();
# Usage: MainMenu();
sub MainMenu {
	LoadData();
	while(1) {
		system("clear");
		print "Welcome to the day planner services user management console\n\n";
		print "Menu:\n";
		print "A - Add a new user\nD - Delete a user\n";
		print "E - Edit a user\n";
		print "C - Change the level of a user\n";
		print "V - View the user list\n";
		print "I - View information about a user\n";
		print "R - Tell the day planner services daemon to reload the userlist\n";
		print "U - Display the daemon uptime\n";
		print "Q - Quit and save\n";
		my $Input = GetInput("Selection: ", "ADECVIQRU");
		if($Input =~ /q/i) {
			exit(0);
		} elsif ($Input =~ /a/i) {
			AddUser();
		} elsif ($Input =~ /d/i) {
			DeleteUser();
		} elsif ($Input =~ /e/i) {
			ChangeUserSettings();
		} elsif ($Input =~ /c/i) {
			ChangeUserLevel();
		} elsif ($Input =~ /v/i) {
			UserList();
		} elsif ($Input =~ /i/i) {
			GetUserInfo();
		} elsif ($Input =~ /r/i) {
			DaemonReloadUsers();
			WaitContinue();
		} elsif ($Input =~ /u/i) {
			DaemonUptime();
		}
	}
}

MainMenu();
