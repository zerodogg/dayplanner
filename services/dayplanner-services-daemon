#!/usr/bin/perl
# dayplanner-services-daemon
# $Id$
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# TODO: Maybe we should get -T enabled

use strict;
use warnings;
require 5.8.1;				# Require perl 5.8 to ensure things work smoothly
					# (5.8.1 introduced some security enhancements we need)
#use IO::Socket::SSL;	TODO: Implement this instead of IO::Socket::INET
use IO::Socket::INET;
use IO::Select;
use Getopt::Long;
use Digest::MD5 qw(md5_base64);
use Data::Dumper;
use Mail::Sendmail;
use Sys::Hostname;
use POSIX qw/cuserid setuid/;

#my $Server;
my $ConnectionSelect;
my $Shutdown;

my $OutputVeryVerbose = 1;
my $OutputVerbose = 1;
my $DebuggingOutput = 1;
my $DropToUID;
my $AdminSocket;
my @Ports;
my $StartedAt = time();
my $ConfFile = "./dpservices.conf";

my %ActiveUsers;	# Currently active users
my %Clients;		# Hash of current network clients
my %Users;		# User list
my %Security;		# Security specific stuff. For now only handles banning
			# of specific IP adresses.
			# TODO: Should be cleaned once every day.
my %Servers;

# TODO: Not all user levels are fully functional
# level 0 = EXPIRED - no access at all
# level 1 = EXPIRED - read-only access
# level 2 = ACTIVE - rw access
# level 3 = ACTIVE - rw access
# level 4 = ADMIN - rw access and ADMIN command access

my %Config;
my $RCSRev = '$Id$';
my $Version = "0.3 ALPHA";

$SIG{INT} = sub {
	foreach(keys(%Servers)) {
		close($_);
	}
	close("$Config{DataPath}/adminsocket");
	unlink("$Config{DataPath}/adminsocket");
	print "Shutdown by SIG$_[0]\n";
	exit(0);
};
$SIG{TERM} = $SIG{INT};

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE HELPER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Load the services config file
# Usage: LoadServicesConfig(FILE);
sub LoadServicesConfig {
	my $File = $_[0];
	die("The configuration file $File does not exist.\n") unless -r $File;

	my %ConfigOptions = (
		DataPath => '.',
		AdminMail => '^.+@.+$',
		HTMLBase => ".",
		HTMLScript => ".",
		Ports => '^[\d\s]+$',
		DropToUID => '^\d*$',
	);

	# Load the configuration file into the %Config hash
	LoadConfigFile($File, \%Config, \%ConfigOptions, 1) or die("Errors in the configuration file, unable to continue\n");
	# Make sure we have all the options
	my $OptionsMissing = 0;
	foreach(keys(%ConfigOptions)) {
		if(not defined($Config{$_})) {
			print "The configuration option $_ is missing!\n";
			$OptionsMissing = 1;
		}
	}
	die("Errors in the configuration file, unable to continue\n") if($OptionsMissing);
	# Populate the ports
	foreach(split(/\s+/, $Config{Ports})) {
		push(@Ports, $_);
	}
	# Set $DropToUID if needed
	if($Config{DropToUID} and not $DropToUID) {
		$DropToUID = $Config{DropToUID};
	}
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Output a debugging message if needed
# Usage: IntDebug(MESSAGE);
sub IntDebug {
	if ($DebuggingOutput) {
		IntOutputMSG("DEBUG: $_[0]\n");
	}
}

# Purpose: Output a message when in very verbose mode
# IntVeryVerbose(MESSAGE);
sub IntVeryVerbose {
	if ($OutputVeryVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a message when in verbose mode
# Usage: IntVerbose(MESSAGE);
sub IntVerbose {
	if ($OutputVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a properly formatted internal message
# Usage: IntOutputMSG(MESSAGE);
sub IntOutputMSG {
	my ($lsec,$lmin,$lhour,$lmday,$lmon,$lyear,$lwday,$lyday,$lisdst) = localtime(time);
	$lhour = "0$lhour" unless $lhour >= 10;
	$lmin = "0$lmin" unless $lmin >= 10;
	$lsec = "0$lsec" unless $lsec >= 10;
	print "[$lhour:$lmin:$lsec] $_[0]";
}

# Purpose: Print a warning to STDERR with proper output
# Usage: IntWarn("Warning");
sub IntWarn {
	warn "Warning: $_[0]\n";
}

# Purpose: Set the program status
# Usage: SetStatus(STATUS);
sub SetStatus {
	$0 = "dayplanner-services-daemon [$_[0]]";
}

# Purpose: Write a configuration file
# Usage: WriteConfigFile(/FILE, \%ConfigHash, \%ExplanationHash);
sub WriteConfigFile {
	my ($File, $Config, $Explanations) = @_;

	# Open the config for writing
	open(my $CONFIG, ">", "$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		IntVerbose("Unable to save the configuration file $File: $!");
		return(0);
	};
	if(defined($Explanations->{HEADER})) {
		print $CONFIG "# $Explanations->{HEADER}\n";
	}
	foreach(sort(keys(%{$Config}))) {
		next unless length($Config->{$_});	# Don't write empty options
		if(defined($Explanations->{$_})) {
			print $CONFIG "\n# $Explanations->{$_}";
		}
		print $CONFIG "\n$_=$Config->{$_}\n";
	}
	close($CONFIG);
}

# Purpose: Load a configuration file
# Usage: LoadConfigFile(/FILE, \%ConfigHash, \%OptionRegexHash, OnlyValidOptions?);
#  OptionRegeXhash can be available for only a select few of the config options
#  or skipped completely (by replacing it by undef).
#  If OnlyValidOptions is true it will cause LoadConfigFile to skip options not in
#  the OptionRegexHash.
sub LoadConfigFile {
	my ($File, $ConfigHash, $OptionRegex, $OnlyValidOptions) = @_;

	my $Status = 1;

	open(my $CONFIG, "<", "$File") or do {
		print "Unable to read config settings: $File:$!\n";
		return(0);
	};
	while(<$CONFIG>) {
		next if m/^\s*(#.*)?$/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		if($OnlyValidOptions) {
			unless(defined($OptionRegex->{$Option})) {
				IntVerbose("Unknown configuration option \"$Option\" in $File: Ignored.");
				next;
			}
		}
		unless(defined($Value)) {
			IntVerbose("Empty value for option $Option in $File");
			$Status = 0;
		}
		if(defined($OptionRegex) and defined($OptionRegex->{$Option})) {
			my $MustMatch = $OptionRegex->{$Option};
			unless ($Value =~ /$MustMatch/) {
				$Status = 0;
				print "Invalid setting of $Option in the config file: Must match $OptionRegex->{$Option}\n";
				next;
			}
		}
		$ConfigHash->{$Option} = $Value;
	}
	close($CONFIG);
	return($Status);
}

# Purpose: Send an e-mail (sendmail() wrapper)
# Usage: SendMail(TO, SUBJECT, MESSAGE);
# 	Returns an error message on failure. undef otherwise
sub SendMail {
	my($To, $Subject, $Message) = @_;
	my %Message = (
		To => $To,
		From => "Day Planner services daemon <" . cuserid() . '@' . hostname() . ">",
		Subject => "[DPS] " . $Subject,
		Message => $Message,
		"X-Mailer" => "dayplanner-services-daemon//Mail::SendMail",
		"User-Agent" => "dayplanner-services-daemon//Mail::SendMail",
	);
	sendmail(%Message) or return($Mail::Sendmail::error);
	return(undef);
}

# Purpose: Notify the admin about data corruption
# Usage: DataCorruption(USER);
sub DataCorruption {
	my $User = $_[0];

	my $Error = SendMail(
		$Config{AdminMail},
		"Data corruption for user $User!",
		# TODO: Re-add port to this one
		"The data for the user $User was found corrupt by the\nday planner services daemon at " . scalar(localtime(time)) . " on " . hostname() . ".\n\nThis error is very serious, please look into this as soon as possible\n\nRegards,\nthe day planner services daemon",
	);
	if($Error) {
		IntVerbose("WARNING: UNABLE TO SEND MAIL ABOUT DATA CORRUPTION: $Error");
	};
}

# Purpose: Perform specific functions on login failure
# Usage: LoginFailure(IP);
# 	Returns the REFUSED string
sub LoginFailure {
	my $IP = shift;
	$Security{LoginFailures}{$IP}++;
	if($Security{LoginFailures}{$IP} > 9) {
		$Security{Banned}{$IP} = 1;
		delete($Security{LoginFailures}{$IP});
	}
	return("REFUSED");
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE DATA FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Load the data
# Usage: LoadData();
sub LoadData {
	unless(-e "$Config{DataPath}/users.conf") {
		die("$Config{DataPath}/users.conf does not exist");
	}
	%Users = do("$Config{DataPath}/users.conf");
	return(1);
}

# Purpose: Get the data for a specific user
# Usage: $Returned = SendData(USER);
# 
# The returned data is like this:
# MD5_BASE64 BASE64_ENCODED_DPF_DATA
# The first part is the md5sum of the second part
sub SendData {
	my $User = $_[0];
	my %User_DataConfig;
	unless(-e "$Config{DataPath}/$User/dataconfig" and -e "$Config{DataPath}/$User/calendardata") {
		return("ERR NO_DATA");
	}

	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);

	open(my $User_Data, "<", "$Config{DataPath}/$User/calendardata") or return("ERR READFAIL $!");
	my $ReturnData = <$User_Data>;
	close($User_Data);
	unless(defined($User_DataConfig{LastMD5})) {
		return("ERR NO_MD5");
	}
	my $MD5 = md5_base64($ReturnData);
	if($MD5 eq $User_DataConfig{LastMD5}) {
		IntVerbose("Data for user $User sent");
		return("OK $MD5 $ReturnData");
	} else {
		IntVerbose("MD5 verification of data for the user $User failed! Wanted $User_DataConfig{LastMD5} but found $MD5.");
		DataCorruption($User);
		return("ERR MD5_FAILURE");
	}
}

# Purpose: Recieve new data for a specific user
# Usage: $Returned_Status = RecieveData(DATA,USER);
sub RecieveData {
	my $User = $_[1];
	my $Data = $_[0];
	my $THIS_MD5 = $_[0];
	my $LAST_MD5 = $_[0];
	my $FORCE = $_[0];	# NOTE: Use of FORCE is dangerous!
	my %User_DataConfig;

	$THIS_MD5 =~ s/^(\S+)\s+.*$/$1/;
	$LAST_MD5 =~ s/^(\S+)\s+(\S+).*$/$2/;
	$Data =~ s/^(\S+)\s+(\S+)\s+(\S+).*$/$3/;
	$FORCE =~ s/^(\S+)\s+(\S+)\s+(\S+)\s*//;
	unless(length($THIS_MD5) and length($LAST_MD5) and length($Data)) {
		return("ERR FORMATERROR");
	}

	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);
	
	unless($FORCE) {
		if(defined($User_DataConfig{LastMD5})) {
			if(not $LAST_MD5 eq "undef" and not $User_DataConfig{LastMD5} eq $LAST_MD5) {
				return("ERR LASTMD5_NOMATCH $User_DataConfig{LastMD5} - $LAST_MD5");
			}
		}
	}

	my $MD5 = md5_base64($Data);
	unless($MD5 eq $THIS_MD5) {
		return("ERR MD5_MISMATCH # $MD5 - $THIS_MD5");
	}

	# We got this far, write the data
	open(my $OutData, ">", "$Config{DataPath}/$User/calendardata") or do {
		IntVerbose("Unable to open $Config{DataPath}/$User/calendardata for writing!: $!");
		return("ERR WRITEFAILURE");
	};
	print $OutData $Data;
	close($OutData);
	
	$User_DataConfig{LastMD5} = $MD5;

	my %ConfigInfo = (
		LastMD5 => "The MD5 sum of the last data transmitted to the server for this user",
		HEADER => "Data information for $User",
	);

	WriteConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig, \%ConfigInfo);
	IntVerbose("New data for user $User recieved");
	GenHTML($User);
	return("OK");
}

# Purpose: Get the MD5 sum of a users data
# Usage: $Returned = GetMD5(USER);
sub GetMD5 {
	my $User = $_[0];
	my %User_DataConfig;
	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);
	if(defined($User_DataConfig{LastMD5})) {
		return($User_DataConfig{LastMD5});
	} else {
		return("[NONE]");
	}
}

# Purpose: Generate HTML of a users data if needed
# Usage: GenHTML(USER);
sub GenHTML {
	my $User = shift;
	my $Language;
	unless($Users{$User}{settings}{GenHTML}) {
		return(1);
	}
	unless(-d $Config{HTMLBase}) {
		IntDebug("\$Config{HTMLBase} is not set");
		return(undef);
	}
	unless(-x $Config{HTMLScript}) {
		IntDebug("\$Config{HTMLScript} is not valid");
		return(undef);
	}
	if(defined($Users{$User}{settings}{language})) {
		$Language = $Users{$User}{settings}{language};
	} else {
		$Language = "en";
	}
	system("$Config{HTMLScript} --dir '$Config{HTMLBase}/$User' --user $User --pass $Users{$User}{password} --dpfsource '$Config{DataPath}/$User/calendardata' --language $Language");
	IntDebug("Started HTML generating script for user $User: $Config{HTMLScript} --dir '$Config{HTMLBase}/$User' --user $User --pass [HIDDEN] --dpfsource '$Config{DataPath}/$User/calendardata' --language $Language");
	return(1);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE SERVER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Handle commands
# Usage: CommandHandler(COMMAND, HANDLE);
sub CommandHandler {
	my ($Command, $Handle) = @_;
	chomp($Command);
	
	# API Level
	if($Command =~ /^APILEVEL/) {
		my $API = $Command;
		$API =~ s/^APILEVEL\s+(\S*).*$/$1/;
		unless($API eq "04A") {
			IntVerbose("APILEVEL mismatch from $Handle (got $API)");
			return("ERR Unsupported");
		} else {
			$Clients{$Handle}{APIOK} = 1;
			return("OK");
		}
	}
	unless(defined($Clients{$Handle}{APIOK})) {
		return("REFUSED NO_APILEVEL");
	}

	# Authentication
	if($Command =~ /^AUTH/) {
		if(defined($Clients{$Handle}{User})) {
			return("REFUSED ALREADY_AUTHED $Clients{$Handle}{User}");
		}
		# Get the username and password parts
		my $Username = $Command;
		$Username =~ s/^AUTH\s*(\w+)\s+(\w+).*$/$1/;
		my $Password = $Command;
		$Password =~ s/^AUTH\s*(\w+)\s+(\w+).*$/$2/;
		
		# Verify supplied data
		unless(defined($Users{$Username})) {
			IntVeryVerbose("$Handle tried to auth as $Username, but that user doesn't exist");
			return(LoginFailure($Handle->peerhost));
		}
		unless($Users{$Username}{password} eq $Password) {
			IntVerbose("Authentication from $Handle failed as $Username");
			return(LoginFailure($Handle->peerhost));
		}
		# Make sure it's not in use
		if(defined($ActiveUsers{$Username}) and defined($ActiveUsers{$Username}{Handle})) {
			IntDebug("$Handle tried to auth as $Username but $ActiveUsers{$Username}{Handle} is authenticated as that user already");
			return("REFUSED IN_USE");
		}

		# If the user's level is 0 then the user account is expired and we refuse the login.
		if($Users{$Username}{level} eq "0") {
			return("EXPIRED");
		}
		$Clients{$Handle}{User} = $Username;
		$ActiveUsers{$Username}{Handle} = $Handle;
		IntVerbose("$Handle authenticated as $Username");
		return("OK");
	}
	# Require authentication to proceed
	unless(defined($Clients{$Handle}{User})) {
		return("REFUSED AUTHFIRST");
	}

	# Other commands
	if($Command =~ /^GETDATA/) {
		return(SendData($Clients{$Handle}{User}));
	} elsif($Command =~ s/^SENDDATA\s*//) {
		if($Users{$Clients{$Handle}{User}}{level} > 1) {
			return(RecieveData($Command, $Clients{$Handle}{User}));
		} else {
			return("EXPIRED");
		}
	} elsif($Command =~ /^GET_MD5/) {
		return(GetMD5($Clients{$Handle}{User}));
	} elsif($Command =~ s/^ADMIN\s+//) {
		if($Users{$Clients{$Handle}{User}}{level} == 4) {
			return(AdminCommands($Command));
		} else {
			return("REFUSED");
		}
	}
	IntVeryVerbose("Unknown command from " . $Handle->peerhost() . " ($Handle): $Command");
	return("ERR UNKNOWN_COMMAND");
}

# Purpose: Handle ADMIN commands
# Usage: AdminCommands(COMMAND, HANDLE);
sub AdminCommands {
	my ($Command, $Handle) = @_;
	if($Command =~ /^VERSION/) {
		return("$Version - $RCSRev");
	} elsif ($Command =~ /^RELOAD_USERLIST/) {
		IntVerbose("Userlist reloaded");
		LoadData();
		return("DONE");
	} elsif ($Command =~ /^UPTIME/) {
		my $Uptime = time() - $StartedAt;
		$Uptime = sprintf("%u", $Uptime / 60);
		my ($Days, $Hours, $Minutes) = (0,0,0);
		while ($Uptime > 24 * 60) {
			$Days++;
			$Uptime -= 24 * 60;
		}
		while ($Uptime > 60) {
			$Hours++;
			$Uptime -= 60;
		}
		$Minutes = $Uptime;
		my $UptimeString = $Days ? "$Days days " : "" . 
		$Hours ? "$Hours hours " : "" . 
		$Minutes ? "$Minutes minutes" : "";
		unless(length($UptimeString)) {
			$UptimeString = "Less than one minute";
		}
		IntVerbose("Uptime requested ($UptimeString)");
		return($UptimeString);
	}
	return("ERR UNKNOWN_COMMAND");
}

# Purpose: Create the connection selector and open sockets
# Usage: InitNetwork();
sub InitNetwork {
	# Create a new select handle for reading
	$ConnectionSelect = IO::Select->new();
	# Trap SIGPIPE
	$SIG{PIPE} = \&SigpipeHandler;
	# Open the sockets
	foreach my $CurrPort (@Ports) {
		OpenSocket($CurrPort);
	}
	# Drop root privs if needed
	if ($> == 0 or $< == 0) {
		if ($DropToUID) {
			setuid($DropToUID) or die("Unable to drop priveliges: $!");
		}
	}
	# Open up the local communication unix socket
	OpenLocalSocket("$Config{DataPath}/adminsocket");
}

# Purpose: Open a new communication socket on PORT
# Usage: OpenSocket(PORT);
sub OpenSocket {
	my $ListenPort = shift;
	my $NewServer = IO::Socket::INET->new(
					LocalPort => $ListenPort,
					Listen	=> 5,
					Timeout => 15,		# We can't really wait longer as other users might want to connect
			) or die "Unable to create a new socket on $ListenPort: $@\n";
	$Servers{$NewServer} = 1;
	# Add the server to the connection selection object
	$ConnectionSelect->add($NewServer);
}

# Purpose: Open a local communication socket
# Usage: OpenLocalSocket(/PATH/);
sub OpenLocalSocket {
	my $Path = shift;
	$AdminSocket = IO::Socket::UNIX->new(
		Local	=> $Path,
		Type	=> SOCK_STREAM,
		Listen	=> 5,
	) or die("Unable to create the local admin socket on $Path: $@ ($!)\n");
	$Servers{$AdminSocket} = 1;
	# Add the server to the connection selection object
	$ConnectionSelect->add($AdminSocket);
}

# Purpose: Start the main loop
# Usage: MainLoop();
# Requires: OpenSocket(); already performed
sub MainLoop {
	# Loop for eternity
	while (1) {
		SetStatus("waiting for connections");
		# Block until one handle is available or it times out
		my @Ready_Handles = $ConnectionSelect->can_read();
		SetStatus("processing");
		# For each handle...
		foreach my $Handle (@Ready_Handles) {
			# If the handle is $server then it's a new connection
			if (defined($Servers{$Handle})) {
				my $NewClient = $Handle->accept();
				$ConnectionSelect->add($NewClient);
				if($Handle eq $AdminSocket) {
					$Clients{$NewClient}{Admin} = 1;
					IntDebug("New local admin connection on the admin socket");
				} else {
					if ($Security{Banned}{$NewClient->peerhost}) {
						IntDebug("New connection from " . $NewClient->peerhost  . "refused: banned");
						print $NewClient "BANNED\n";
						$ConnectionSelect->remove($NewClient);
					} else {
						IntDebug("New connection from " . $NewClient->peerhost . " on $NewClient");
					}
				}
			}
			# Handle isn't $server, it's an existing connection trying to tell us something
			else {
				# What is it trying to tell us?
				my $Command = <$Handle>;
				# If it is defined then it's a command
				if ($Command) {
					chomp($Command);
					my $Reply;
					if(defined($Clients{$Handle}{Admin}) and $Clients{$Handle}{Admin} == 1) {
						$Reply = AdminCommands($Command, $Handle);
					} else {
						$Reply = CommandHandler($Command, $Handle);
					}
					print $Handle "$Reply\n";
				} 
				# If it isn't, then it closed the connection
				else {
					if(defined($Clients{$Handle}{User})) {
						IntDebug("Connection closed for user $Clients{$Handle}{User} ($Handle)");
						delete($ActiveUsers{$Clients{$Handle}{User}});
					} else {
						IntDebug("Connection closed for $Handle");
					}
					delete($Clients{$Handle});
					$ConnectionSelect->remove($Handle);
				}
			}
		}
		if ($Shutdown) {
			IntVerbose($Shutdown);
			exit(0);
		}
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# INITIALIZATION
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

GetOptions (
	'port|p=i' => \@Ports,
	'switchuid=i' => \$DropToUID,
	'help|h' => sub {
		print "Day planner services daemon version $Version\n\n";
		PrintHelp("-d", "--dayplannerdir", "Which directory to use as the dayplanner config dir");
		PrintHelp("", "--version", "Display version information and exit");
		PrintHelp("-h,", "--help", "Display this help screen");
		PrintHelp("-n,", "--nofork", "Don't go into the background (and log to STDOUT/STDERR instead of the logfile)");
		PrintHelp("-v,", "--verbose", "Be verbose");
		PrintHelp("-V,", "--veryverbose", "Be very verbose");
		PrintHelp("-c,", "--conffile", "Set which configuration file to use");
		PrintHelp("", "--switchuid", "Switch to the supplied UID after startup");
		PrintHelp("-p", "--port", "Additional ports to listen on (can be supplied multiple times)");
		PrintHelp("-D,", "--debug", "Output debugging information");
		exit(0);
	},
	'c|config|configfile|conffile=s' => \$ConfFile,
	'debug|D' => sub {
		$DebuggingOutput = 1;
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'verbose|v' => \$OutputVerbose,
	'veryverbose|V' => sub {
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'version' => sub {
		print "Day planner services daemon version $Version\n";
		print "RCS revision: $RCSRev\n";
		exit(0);
	},
) or die "See $0 --help for more information\n";

print "WARNING: This is alpha software. Use at your own risk. See README for more information\n\n";

SetStatus("starting");
umask(077);
LoadServicesConfig($ConfFile);
LoadData();
InitNetwork();
MainLoop();
