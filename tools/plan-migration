#!/usr/bin/perl
# plan-migration
# Migrate a "Plan" setup to a Day Planner one.
# $Id$
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use strict;
use warnings;
use Data::Dumper;
use File::Basename;
use Getopt::Long;

my %PlanConvertHash;
my %CalendarContents;
my %BirthdayContents;
my %InternalConfig;
my $DayplannerDataDir = "$ENV{HOME}/.dayplanner";
my $DPD_Short = "~/.dayplanner";
my $MainEventsFile = "events.dpd";                      # The filename to save the events to
my $BirthdayFile = "birthdays.dpd";                     # The filename to save birthdays to
my $Verbose;
my $Migrate;
my $Version = 0.1;
my $RCSVer = '$Id$';
my $PlanDir;

# Purpose: Repair a conflict between two events
# Usage: my $NewTime = PlanConvert_RepairConflict(YEAR, MONTH, DAY, TIME);
sub PlanConvert_RepairConflict($$$$) {
	my ($Year, $Month, $Day, $Time) = @_;
	my ($Hour, $Minute) = split(/:/, $Time);
	
	# If the summaries and fulltexts are identical we just ignore the conflict because it doesn't matter one bit
	if ($CalendarContents{$Year}{$Month}{$Day}{"$Hour:$Minute"}{summary} eq $PlanConvertHash{Summary}) {
		if (defined($CalendarContents{$Year}{$Month}{$Day}{"$Hour:$Minute"}{summary}) and defined($PlanConvertHash{Fulltext})) {
			if ($CalendarContents{$Year}{$Month}{$Day}{"$Hour:$Minute"}{fulltext} eq $PlanConvertHash{Fulltext}) {
				return($Time);
			}
		} else {
			return($Time);
		}
	}
	
	while(defined($CalendarContents{$Year}{$Month}{$Day}{"$Hour:$Minute"})) {
		$Hour =~ s/^0(.*)/$1/;
		$Minute =~ s/^0(.*)/$1/;
		$Minute++;
		if ($Minute > 59) {
			if ($Hour >= 23) {
				warn "Unable to resolve conflicting events on $PlanConvertHash{Day}-$PlanConvertHash{Month}-$PlanConvertHash{Year} at $PlanConvertHash{Time}: \"$CalendarContents{$PlanConvertHash{Year}}{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Time}}{summary}\" and \"$PlanConvertHash{Summary}\". Data will be lost! You may want to resolve it manually after the migration has finished.\n";
				return($Time);
			}
			$Minute = 0;
			$Hour++;
		}
		if ($Hour <= 9) {
			$Hour = "0$Hour";
		}
		if ($Minute <= 9) {
			$Minute = "0$Minute";
		}
	}
	return("$Hour:$Minute");
}

# Purpose: Print a verbose message if needed
# Usage: PC_Verbose(MESSAGE);
sub PC_Verbose ($) {
	if ($Verbose) {
		print "$_[0]\n";
	}
}

# Purpose: Purge the current %PlanConvertHash buffer and put it into %CalendarContents
# Usage: PlanConvert_PurgeBuffer();
sub PlanConvert_PurgeBuffer {
	if(defined($PlanConvertHash{Day})) {
		if ($PlanConvertHash{Type} eq 'normal') {
			# Check for conflicts
			if (defined($CalendarContents{$PlanConvertHash{Year}}{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Time}})) {
				# Okay, it conflicts, call a verbosity check to see if we should print the warning
				PC_Verbose("Conflicting events on $PlanConvertHash{Day}-$PlanConvertHash{Month}-$PlanConvertHash{Year} at $PlanConvertHash{Time}: \"$CalendarContents{$PlanConvertHash{Year}}{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Time}}{summary}\" and \"$PlanConvertHash{Summary}\"");
				# Try to fix it
				$PlanConvertHash{Time} = PlanConvert_RepairConflict($PlanConvertHash{Year},$PlanConvertHash{Month},$PlanConvertHash{Day},$PlanConvertHash{Time});
			}
			if (defined($PlanConvertHash{Summary})) {
				$CalendarContents{$PlanConvertHash{Year}}{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Time}}{summary} = $PlanConvertHash{Summary};
				delete($PlanConvertHash{Summary});
			}
			if (defined($PlanConvertHash{Fulltext})) {
				$CalendarContents{$PlanConvertHash{Year}}{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Time}}{fulltext} = $PlanConvertHash{Fulltext};
				delete($PlanConvertHash{Fulltext});
			}
			delete($PlanConvertHash{Day});
			delete($PlanConvertHash{Month});
			delete($PlanConvertHash{Year});
			delete($PlanConvertHash{Time});
		} elsif ($PlanConvertHash{Type} eq 'bday') {
			if (defined($PlanConvertHash{Summary})) {
				$BirthdayContents{$PlanConvertHash{Month}}{$PlanConvertHash{Day}}{$PlanConvertHash{Summary}} = 1;
				delete($PlanConvertHash{Summary});
			}
			delete($PlanConvertHash{Day});
			delete($PlanConvertHash{Month});
			delete($PlanConvertHash{Year});
			delete($PlanConvertHash{Time});
			delete($PlanConvertHash{Fulltext});
		} else {
			die "BUG!!! Invalid type: $PlanConvertHash{Type}\n";
		}
		$PlanConvertHash{Type} = 'normal';
	}
}

# Purpose: Convert the file supplied
# Usage: PlanConvert_PurgeBuffer(/path/to/file);
sub PlanConvert_ProcessFile ($) {
	$PlanConvertHash{Type} = 'normal';

	open(PLAN_FILE,$_[0]) or do {
		warn("Unable to open $_[0]: $!\n");
		return(0);
	};
	my $LineNo = 0;
	foreach(<PLAN_FILE>) {
		$LineNo++;
		next if /^\s*(O|o|t|e|l|a|y|P|p|m|L|u|E)/;	# These are Plan specific stuff, just ignore them
		chomp;
		if (/^\s*(N)/) {		# Entry equalent to the dayplanner summary
			my $Summary = $_;
			$Summary =~ s#^\s*N\s+(.*)#$1#;
			$PlanConvertHash{Summary} = $Summary;
		} elsif (/^\s*(M)/) {		# Entry equalent to the dayplanner fulltext
			my $Fulltext = $_;
			$Fulltext =~ s#^\s*M\s+(.*)#$1#;
			if(defined($PlanConvertHash{Fulltext})) {
				$PlanConvertHash{Fulltext} = "$PlanConvertHash{Fulltext} $Fulltext";
			} else {
				$PlanConvertHash{Fulltext} = $Fulltext;
			}
		} elsif (/^\s*(R)/) {		# These we just skip but might parse at some point
			if (/^\s*R\s+0\s+0\s+0\s+0\s+1/) {
				$PlanConvertHash{Type} = 'bday';
			} else {
				next;
			}
		} elsif (/^\s*\d/) {		# Okay, it starts with a digit, it's a new date
			PlanConvert_PurgeBuffer();
			my ($Day,$Month,$Year,$Time) = ($_,$_,$_,$_);
			# Get the day
			$Day =~ s#^\s*\d+/(\d+)/.*#$1#;
			# Get the month
			$Month =~ s#^\s*(\d+)/\d+/.*#$1#;
			# Get the year
			$Year =~ s#^\s*\d+/\d+/(\d+)\s+.*#$1#;
			# Get the time
			$Time =~ s#\s*\d+/\d+/\d+\s+(\d+:\d+):\d+\s+.*#$1#;
			# Convert the time to a more dayplannerish format
			$Time = "00:00" if $Time eq '99:99';
			if ($Time =~ /^\d+:\d$/) {
				$Time = $Time . 0;
			}
			if ($Time =~ /^\d:\d*$/) {
				$Time = 0 . $Time;
			}
			# Set the variables in the hash
			$PlanConvertHash{Day} = $Day;
			$PlanConvertHash{Month} = $Month;
			$PlanConvertHash{Year} = $Year;
			$PlanConvertHash{Time} = $Time;
		} else {
			warn("WARNING: Unrecognized line: $_[0]:$LineNo: $_\nPlease report this\n\n");
			next;
		}
	}
}

# Purpose: Load the dayplanner data file
# Usage: LoadDayplannerData();
sub LoadDayplannerData () {
	if (-r "$DayplannerDataDir/$MainEventsFile") {
		%CalendarContents = do("$DayplannerDataDir/$MainEventsFile");
	}
	if (-r "$DayplannerDataDir/$BirthdayFile") {
		%BirthdayContents = do("$DayplannerDataDir/$BirthdayFile");
	}
}

# Purpose: Start converting plan
# Usage: MigratePlan();
sub MigratePlan () {
	my $FoundPlanDir = 0;
	$| = 1;

	my $ShortDataDir = $DayplannerDataDir;
	$ShortDataDir =~ s/^$ENV{HOME}/~/;
	print "Loading day planner data from $ShortDataDir/...";
	LoadDayplannerData();
	print "done\n";
	
	print "Migrating plan data...";
	
	foreach my $Dir ($PlanDir, "$ENV{HOME}/.plan","$ENV{HOME}/.plan.dir") {
		if (defined($Dir) and -d $Dir and -e "$Dir/dayplan") {
			foreach my $File (<$Dir/*>) {
				next if basename($File) =~ /^(lock\.pland|pland|holiday)$/;
				PlanConvert_ProcessFile($File);
				PlanConvert_PurgeBuffer();
				$FoundPlanDir = 1;
				print ".";
			}
		}
	}
	unless ($FoundPlanDir) {
		print "failed\n\n";
		die("Unable to find a directory containing plan data. Use --plandir to tell me about one\n");
	}
	print "done\n";
	
	$Data::Dumper::Indent = 1;
	$Data::Dumper::Purity = 1;
	$Data::Dumper::Sortkeys = 1;
	
	print "Writing data file: $ShortDataDir/$MainEventsFile...";
	open(MainCalendar, ">$DayplannerDataDir/$MainEventsFile") or die "failed\nUnable to open $ShortDataDir/$MainEventsFile for writing: $!\n";
	print MainCalendar "# Day planner data file written by the plan migration script\n# Saved on ", scalar(localtime(time)), "\n";
	print MainCalendar Data::Dumper->Dump([\%CalendarContents], ["*CalendarContents"]);
	close(MainCalendar);
	print "done\n";

	print "Writing data file: $ShortDataDir/$BirthdayFile...";
	open(Birthdays, ">$DayplannerDataDir/$BirthdayFile") or die "failed\nUnable to open $ShortDataDir/$BirthdayFile for writing: $!\n";
	print Birthdays "# Day planner data file written by the plan migration script\n# Saved on ", scalar(localtime(time)), "\n";
	print Birthdays Data::Dumper->Dump([\%BirthdayContents], ["*BirthdayContents"]);
	close(Birthdays);
	print "done\n\n";

	print "Your plan data has now been migrated to day planner. Enjoy :)\n";
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp($$$) {
        printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Load the state file
# Usage: LoadStateFile(DIRECTORY, FILENAME);
sub LoadStateFile($$) {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];

	
	# Open the statefile
	open(STATE, "<", "$Dir/$File") or do {
		return(1);
	};
	
	# Load the config
	foreach(<STATE>) {
		next if m/^\s*(#.*)?$/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		$InternalConfig{$Option} = $Value;
	}
	close(STATE);
}

# Purpose: Display the help(ful) information
# Usage: Help();
sub Help () {
	print "Plan to day planner migration program version $Version\n\n";
	print "Usage: $0 --migrate [OPTIONS]\n";
	PrintHelp("-m", "--migrate", "Do the migration");
	PrintHelp("-d", "--dpdir", "Use the directory supplied to this commandline option instead");
	PrintHelp("", "", "of $DPD_Short");
	PrintHelp("-p", "--plandir", "Try to get plan data from this directory");
	PrintHelp("-h", "--help", "Display this help screen");
	print "\nI migrate the data to $DPD_Short by default, you can use --dpdir to\n";
	print "override this default\n";
	print "I also know some of the default plan directories and will try to migrate from those.\n";
	print "You may inform me about another plan directory with --plandir if needed\n";
	exit(0);
}

GetOptions (
	'h|help' => sub { 
		Help(); 
	},
	'm|migrate' => \$Migrate,
	'd|dpdir=s' => sub {
		unless (-e $_[1]) {
			die "$_[1] does not exist\n";
		}
		unless (-d $_[1]) {
			die "$_[1] is not a directory\n";
		}
		unless (-w $_[1]) {
			die "$_[1] is not writeable by me!\n"
		}
		$DayplannerDataDir = $_[1];
	},
	'p|plandir=s' => \$PlanDir,
	'v|verbose' => \$Verbose,
) or die "See $0 --help for more information\n";

Help() unless $Migrate;

unless (-e "$DayplannerDataDir/events.dpd") {
	die("$DayplannerDataDir does not seem to be a day planner data dir (no events.dpd)\nPlease run day planner once before using this program\n");
}

MigratePlan();
