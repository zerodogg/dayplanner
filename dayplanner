#!/usr/bin/perl
# Day planner
# A graphical day planner written in perl that uses Gtk2
# Copyright (C) Eskild Hustvedt 2006
# $Id$
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

require 5.6.0;			# We need perl 5.6.0 at the very least
				# and even this is mostly untested.
use strict;			# Force strict coding
use warnings;			# Tell perl to warn about things
use Locale::gettext;		# Allow the program to be translated
use POSIX;			# We need strftime
use Gtk2; 			# Use Gtk2 :)
use Data::Dumper;		# Our save format is that of Data::Dumper
use Gtk2::SimpleList;		# We use Gtk2::SimpleList to create the eventlist
use Gtk2::Gdk::Keysyms;		# Easier keybindings
use Getopt::Long;		# Commandline options
use Cwd;			# We need Cwd::Realpath to find out which directory we live in
use File::Basename;             # We meed dirname to help Cwd::Realpath finding the directory
use IO::Socket;			# Network layer to communicate with the daemon
use File::Copy;			# We need to copy the holiday file
use FindBin;			# So that we can detect module dirs during runtime
use MIME::Base64;		# Used for import/export
use Digest::MD5 qw(md5_base64);	# Used for import/export
use File::Path qw/mkpath/;	# We need mkpath
# So that we can use a local Date::HolidayParser
use lib "$FindBin::RealBin/modules/Date-HolidayParser/lib/";
use lib "$FindBin::RealBin/modules/";
use Date::HolidayParser;	# Parsing of .holiday files

# Scalars
my $Version = "0.3";
my $RCSRev = '$Id$';
my $MainEventsFile = "events.dpd";			# The filename to save the events to
my $SaveToDir;						# The configuration and eventlist directory (set later)
my $HolidayFile;					# The file to load holiday definitions from (set later)
my $BirthdayFile = "birthdays.dpd";			# The filename to save birthdays to
my $SpecialEventsFile = "special_events.dpd";		# The filename to save events with special settings
my $AllDayEventsFile = "allday_events.dpd";		# The filename to save all-day events to
my $ConfigFile = "dayplanner.conf";			# The filename to save the configuration to
my $Gettext = Locale::gettext->domain("dayplanner");	# Set the gettext domain
my $DaemonName = 'dayplanner-daemon';			# The name of the daemon
my $DaemonOnline = 0;					# Is the daemon online?
my $DaemonInitialized = 0;				# Has the daemon been initialized?
my $DaemonSocketName = 'dayplannerd';			# The name of the daemon socket
my $DaemonSocket;					# The variable to connect to

setlocale(LC_ALL, "" );
textdomain("dayplanner");

# Find out if we have a locale directory in our main dir
if (-d "$FindBin::RealBin/locale/") {
	if(defined($ENV{LC_ALL}) or defined($ENV{LANG})) {
		my $I18N;
		if(defined($ENV{LC_ALL}) and length($ENV{LC_ALL})) {
			$I18N = $ENV{LC_ALL};
		} else {
			$I18N = $ENV{LANG};
		}
		if($I18N =~ /:/) {
			$I18N =~ s/^(.+):.*$/$1/;
		}
		if (-e "$FindBin::RealBin/locale/$I18N/LC_MESSAGES/dayplanner.mo") {
			bindtextdomain("dayplanner", "$FindBin::RealBin/locale");
		}
	}
}

# Arrays
my @SaveFallbackDirs = (				# The directories to use for fallback saving if we can't save to $SaveToDir
	$ENV{HOME}, "$ENV{HOME}/Desktop", "$ENV{HOME}/Documents", "$ENV{HOME}/tmp", "/tmp", "/var/tmp", "/usr/tmp"
);

# Hashes
my %CalendarContents;		# The contents of the main calendar
my %BirthdayContents;		# The contents of the birthday file
my %SpecialEvents;		# The contents of the special events file
my %AllDayEvents;		# The contents of the all-day events file
my %Holidays;			# The holidays
my %InternalConfig;		# Internal configuration values
my %UserConfig;			# User-selected configuration values
my %DPServices;			# Day planner services hash

# The reason we do not use strftime() or I18N::Langinfo is that these return
# values in random encodings. By using Gettext->get() we get values
# in a proper encoding
my %MonthNames = (
	1 => $Gettext->get("January"),
	2 => $Gettext->get("February"),
	3 => $Gettext->get("March"),
	4 => $Gettext->get("April"),
	5 => $Gettext->get("May"),
	6 => $Gettext->get("June"),
	7 => $Gettext->get("July"),
	8 => $Gettext->get("August"),
	9 => $Gettext->get("September"),
	10 => $Gettext->get("October"),
	11 => $Gettext->get("November"),
	12 => $Gettext->get("December")
);	# Localized hash of month number => Name values

# AM/PM detection
# The %% in the end is *required*. It works around bugs in recent versions
# of strftime()
my $AM_String = strftime('%p%%', 0,0,0,0,0,106,0);
my $PM_String = strftime('%p%%', 0,0,12,0,0,106,0);
$AM_String =~ s/%p?%?$//;	# Remove junk
$PM_String =~ s/%p?%?$//;	# Remove junk
my $ClockSystem = $AM_String eq "" ? "24" : "12";

# Gtk2 objects
my (
	$CalendarWidget,	$EventlistWidget,	$WorkingAreaHBox,
	$EventlistWin,		$MainWindow,		$Toolbar,
	$ToolbarEditButton,	$MenuEditEntry,		$MenuDeleteEntry,
	$UpcomingEventsBuffer,	$UpcomingEventsWidget,
);	# Gtk objects

my $HolidayParser;	# The Date::HolidayParser object
my $Gtk2Init;		# Info about if gtk2 is initialized or not
my $ShutdownDaemon;	# If we should shut down the daemon on exit

# Global date variables
my (
	$currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst
);

# Window state
($InternalConfig{MainWin_Width}, $InternalConfig{MainWin_Height}) = (600,365);	# Default size is 600x365 - overridden by state.conf

# Set up signal handlers
$SIG{INT} = \&DP_SigHandler;
$SIG{TERM} = \&DP_SigHandler;

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Daemon communication functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Initialize and connect to the daemon
# Usage: DaemonInit();
sub DaemonInit {
	$DaemonInitialized = 1;
	
	# Handle SIGPIPE
	$SIG{PIPE} = \&DaemonSIGPIPEHandler;

	if (-e "$SaveToDir/$DaemonSocketName") {
		my $ConnectionAttempt = ConnectToDaemon("$SaveToDir/$DaemonSocketName");
		if ($ConnectionAttempt eq 'NOHI') {
			DaemonConnectionErrorHandler();
			return(1);
		} elsif ($ConnectionAttempt eq '1') {
			$DaemonOnline = 1;
			return(1);
		} 
	}
	return(StartDaemon());
}

# Purpose: Start the day planner daemon
# Usage: StartDaemon();
sub StartDaemon {
	foreach(split(/:/, sprintf("%s:%s", dirname(Cwd::realpath($0)), $ENV{PATH} ))) {
		if (-x "$_/$DaemonName") {
			# Yes this is a bit weird statement. But remember that commands return 0 on TRUE
			# and 1-255 on FALSE, so it's the other way around from perl
			unless(system("$_/$DaemonName --force-fork --dayplannerdir $SaveToDir")) {
				if(ConnectToDaemon("$SaveToDir/$DaemonSocketName")) {
					$DaemonOnline = 1;
					return(1);
				}
			}
		}
	}
	DPIntWarn("Unable to start daemon!");
	return(0);
}

# Purpose: Handle SIGPIPE gracefully
# Usage: $SIG{PIPE} = \&DaemonSIGPIPEHandler;
sub DaemonSIGPIPEHandler {
	DPIntWarn("I recieved a SIGPIPE, the daemon is probably offline");
	StartDaemon();
}

# Purpose: Connect to the daemon
# Usage: ConnectToDaemon(/path/to/socket, FORCE/undef);
sub ConnectToDaemon {
	my $HI = 'HI client';
	if(defined($_[1]) and $_[1] eq 'FORCE') {
		$HI = 'HI client FORCE';
	}
	$DaemonSocket = IO::Socket::UNIX->new(
		Peer	=> $_[0],
		Type	=> SOCK_STREAM,
		Timeout	=> 5)
		or return("NOCONNECT");
	$DaemonOnline = 1;	# If DaemonOnline isn't 1 then Daemon_DataSegment won't send the data
	if(Daemon_DataSegment($HI) eq "HI\n") {
		return(1);
	} else {
		$DaemonOnline = 0;
		close($DaemonSocket);
		return("NOHI");
	}
}

# Purpose: Send some data to the daemon
# Usage: Daemon_SendData(DATA);
sub Daemon_SendData {
	if($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("\$DaemonSocket is suddenly undef, attempting reconnect");
			Daemon_AttemptReconnect() or DPIntWarn("Unable to reconnect, expect trouble") and return(0);
		}
		if(print $DaemonSocket "$$ $_[0]","\n") {
			return(1);
		} else {
			DPIntWarn("Problem sending data to the daemon: $!");
		}
	} 
	return(0);
}

# Purpose: Reconnect after $DaemonSocket for some reason has gone undef
# Usage: Daemon_AttemptReconnect();
sub Daemon_AttemptReconnect {
	if(ConnectToDaemon("$SaveToDir/$DaemonSocketName", undef) eq 'NOHI') {
		return(undef);
	} else {
		return(1);
	}
}

# Purpose: Get some data from the daemon
# Usage: $Data = Daemon_GetData();
sub Daemon_GetData {
	if($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("\$DaemonSocket is suddenly undef, attempting reconnect");
			Daemon_AttemptReconnect() or DPIntWarn("Unable to reconnect, expect trouble") and return("ERR NOT_ONLINE");
		}
		my $Data = <$DaemonSocket>;
		unless(defined($Data)) {
			return("ERR UNABLE_TO_GET_DATA");
		}
		return($Data);
	} else {
		return("ERR NOT_ONLINE");
	}
}

# Purpose: Send something to the daemon and then return the daemons reply
# Usage: $Reply = Daemon_DataSegment(DATA);
sub Daemon_DataSegment {
	if($DaemonOnline) {
		if(Daemon_SendData($_[0])) {
			return(Daemon_ErrorHandler(Daemon_GetData()));
		}
	} else {
		return("ERR NOT_ONLINE");
	}
}

# Purpose: Close the connection to the daemon (shutdown if $ShutdownDaemon);
# Usage: CloseDaemon();
sub CloseDaemon {
	if ($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("\$DaemonSocket is suddenly undef. Doesn't matter though since we're closing the connection anyway.");
		} else {
			if($ShutdownDaemon) {
				my $GetDaemon = Daemon_DataSegment('SHUTDOWN');
				chomp($GetDaemon);
				unless($GetDaemon eq 'okay') {
					DPIntWarn("The daemon replied \"$GetDaemon\" to my SHUTDOWN request!");
				}
			} else {
				my $GetDaemon = Daemon_DataSegment('BYE');
			}
			close($DaemonSocket);
		}
		$DaemonOnline = 0;
	}
	return(1);
}

# Purpose: Display an error message when an error is recieved from the daemon
# Usage: Daemon_ErrorHandler(Daemon_GetData());
sub Daemon_ErrorHandler {
	if ($_[0] =~ /^ERR\s+/) {
		DPIntWarn("Recived error from daemon: \"$_[0]\"");
	}
	if(defined($_[1])) {
		DPIntWarn("Weird multi-return response from caller: [1]=\"$_[1]\"");
	}
	return($_[0]);
}

# Purpose: Display an error dialog about the inability to connect to the daemon
# Usage: DaemonConnectionErrorHandler();
sub DaemonConnectionErrorHandler {
	if($Gtk2Init) {
		my $ErrorDialog = Gtk2::MessageDialog->new (undef,
						'destroy-with-parent',
						'error',
						'none',
						 $Gettext->get("Another instance of day planner appears to be running. Please quit the currently running instance of day planner before continuing\n\nRunning two instances of day planner can be forced. However that is not recommended as it may lead to data loss or corruption."));

		$ErrorDialog->add_buttons(
			$Gettext->get('_Force') => 'reject',
			'gtk-ok' => 'accept',
		);
	
		$ErrorDialog->set_default_response('accept');
		if($ErrorDialog->run eq 'accept') {
			$ErrorDialog->destroy;
			exit(0)
		} else {
			$ErrorDialog->destroy;
			unless (ConnectToDaemon("$SaveToDir/$DaemonSocketName", 'FORCE')) {
					DPError($Gettext->get("Unable to force the start. This is likely due to a bug in the program, please contact the day planner developers."));
					exit(1);
				}
		}
	} else {
		die("Another instance of day planner appears to be running, unable to continue\n");
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Services layer
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Return better errors than IO::Socket::INET does.
# Usage: my $ERROR = IO_Socket_INET_Errors($@);
# 	Errors:
#		OFFLINE = Network is unreachable
#		REFUSED = Connection refused
#		BADHOST = Bad hostname (should often be handled as OFFLINE)
#		* = Anything else simply returns $@
sub IO_Socket_INET_Errors {
	my $Error = shift;
	# TODO: There are probably quite a few unhandled errors. At least timeout.
	if($Error =~ /Network is unreachable/) {
		return("OFFLINE");
	} elsif ($Error =~ /Bad hostname/) {
		return("BADHOST");
	} elsif ($Error =~ /Connection refused/) {
		return("REFUSED");
	} else {
		return($Error);
	}
}


# Purpose: Connect to a day planner services server.
# Usage: my $Return = DPS_Connect(HOST, PORT, USER, PASS);
# 		The arguments are optional and will be read from %DPServices if not supplied
sub DPS_Connect {
	my ($Host, $Port, $User, $Password) = @_;
	$Host = $Host ? $Host : $DPServices{host};
	$Port = $Port ? $Port : $DPServices{port};
	$User = $User ? $User : $DPServices{user};
	$Password = $Password ? $Password : $DPServices{pass};
	my $Error;
	# Connect
	DPS_Status("Connecting",0);
	my $OLDLocale = setlocale(LC_ALL, "C");		# Need errors that are not localized for IO_Socket_INET_Errors();
	$DPServices{socket} = IO::Socket::INET->new(
					PeerAddr => $Host,
					PeerPort => $Port,
					Timeout => 30,
			) or do { $Error = $@; };
			
	setlocale(LC_ALL, ""); #, $OLDLocale);	# Reset the locale
	# Process errors if any occurred
	if($Error) {
		# If we have already displayed an error to the user this session, don't do it again
		if(defined($DPServices{Offline}) and $DPServices{Offline} eq 1) {
			DPS_Error(undef, "Unable to connect to $Host on port $Port: $@");
			return(undef);
		}

		$Error = IO_Socket_INET_Errors($Error);	# Get errors that are easier to process

			# Process network unreachable and bad hostname
		if($Error eq "OFFLINE" or $Error eq "BADHOST") {
			$DPServices{Offline} = 1;
			DPS_Error("Unable to connect to the Day Planner services server ($Host:$Port). You're probably not connected to the internet", "Unable to connect to $Host on port $Port: $@ ($Error)");
		}
			# Process connection refused
		elsif($Error eq "REFUSED") {
			DPS_Error("Unable to connect to the Day Planner services server ($Host:$Port). The connection was refused by the server. Please verify your Day Planner services settings.\n\nIf this problem persists, please contact your service provider", "Unable to connect to $Host on port $Port: $@ ($Error)");
		} 
			# Process unknown errors
		else {
			DPS_Error("Unable to connect to the day planner services server ($Host:$Port). If this problem persists please contact your service provider.", "Unable to connect to $Host on port $Port: $@");
		}
		return(undef);
	}

	# The connection didn't fail, so delete $DPServices{Offline} if it exists
	delete($DPServices{Offline});

	# Authenticate
	my $APIREPLY = DPS_DataSegment("APILEVEL 0");
	return(undef) if DPS_ErrorIfNeeded("OK", $APIREPLY, sub { DPS_Disconnect();  DPS_Error("The day planner services server you are connecting to does not support this version of day planner ($Version).", "API error received from the server.");});
	DPS_Status("Connecting",0.2);
	my $AUTHREPLY = DPS_DataSegment("AUTH $User $Password");
	DPS_Status("Connecting",0.4);
	return(undef) if DPS_ErrorIfNeeded("OK", $AUTHREPLY, sub { DPS_Disconnect(); DPS_Error("The username and/or password is incorrect.","Authentication error");});
	return("OK");
}

# Purpose: Do something when an error has occurred
# Usage: my $Return = DPS_ErrorIfNeeded(EXPECTED_REPLY, RECIEVED_REPLY, CODEREF);
# 	The CODEREF will be run if EXPECTED_REPLY does not eq RECIEVED_REPLY
sub DPS_ErrorIfNeeded {
	my ($Expected, $Recieved, $ErrorSub) = @_;
	unless($Expected eq $Recieved) {
		$ErrorSub->($Recieved);
		return(1);
	} else {
		return(0);
	}
}

# Purpose: Disconnect from a day planner services daemon
# Usage: DPS_Disconnect();
sub DPS_Disconnect {
	my $Socket = $DPServices{socket};
	close($Socket);
	delete($DPServices{socket});
	return(1);
}

# Purpose: Send data to a day planner services daemon and get the reply
# Usage: my $Reply = DPS_DataSegment(DATA_TO_SEND);
sub DPS_DataSegment {
	my $Socket = $DPServices{socket};
	print $Socket "$_[0]\n";
	my $Data = <$Socket>;
	chomp($Data);
	return($Data);
}

# Purpose: Repair a checksum mismatch
# Usage: DPS_RepairData();
# 	returns true on success, false on failure
sub DPS_RepairData {
	my $ProgressWin = DPCreateProgressWin("Repairing","Getting data",0);
	my $RawData = DPS_Perform("GET_RAW");
	if(defined($RawData)) {
		$ProgressWin->{ProgressBar}->set_fraction(0.4);
		$ProgressWin->{ProgressBar}->set_text("Parsing and repairing");
		my ($PossibleCorruption,@Conflicts) = DPF_ParseData($RawData);
		$ProgressWin->{ProgressBar}->set_fraction(1);
		$ProgressWin->{Window}->destroy();
		# TODO: Process conflicts
		return(1);
	} else {
		DPError("A fatal error occurred while attempting repair");
		return(0);
	}
}

# Purpose: Get day planner data from a services server
# Usage: DPS_GetData(RAW?);
sub DPS_GetData {
	my $Raw = $_[0];
	my $MainData;
	return unless DPS_Connect();
	DPS_Status("Downloading data",0.5);
	my $ServerMD5 = DPS_DataSegment("GET_MD5");
	# If the MD5 on the server is identical to ours we don't need to download the data
	if(not $ServerMD5 =~ /^(\[NONE\]|ERR)/ and $ServerMD5 eq $InternalConfig{DPS_LastMD5}) {
		DPS_Disconnect();
		DPS_Status("Done", 1);
		return(1);
	}
	my $Data = DPS_DataSegment("GETDATA");
	if($Data =~ /^OK/) {
		my $Initial = $Data;
		my $MD5 = $Data;
		$MainData = $Data;
		$Initial =~ s/^(\S+)\s+.*$/$1/;
		$MD5 =~ s/^(\S+)\s+(\S+)\s+.*/$2/;
		$MainData =~ s/^(\S+)\s+(\S+)\s+(\S+)\s*$/$3/;
		return(1) if $InternalConfig{DPS_LastMD5} eq $MD5;
		unless(md5_base64($MainData) eq $MD5) {
			DPS_Error("The data corrupted itself during download. You may want to attempt to synchronize again.","MD5 mismatch during download: got " . md5_base64($MainData) . " expected $MD5");
		} else {
			$MainData = decode_base64($MainData);
			unless($Raw) {
				my ($DP_OnlyBirthdays, $DP_Exportedby, $DP_ExportedAt, %BirthdayCalendarContent, %MainCalendarContent);
				eval($MainData) or do {
					DPSError("Failed to parse the data recieved. This is a fatal error. Please contact your service provider","Data parse error: $@");
					return(undef);
				};
				%BirthdayContents = %BirthdayCalendarContent;
				%BirthdayCalendarContent = ();
				unless($DP_OnlyBirthdays) {
					%CalendarContents = %MainCalendarContent;
					%MainCalendarContent = ();
				}
				$InternalConfig{DPS_LastMD5} = $MD5;
			}
		}
	} else {
		if($Data =~ /^ERR NO_DATA/) {
			# No data found on the server, this is fine.
		} elsif($Data =~ /^ERR MD5_FAILURE/) {
			DPS_Error("The data is corrupt on the services server. The administrator has been notified about this. If this problem does not go away within a few days, please contact your services provider", "MD5 failure on server");
		} else {
			DPS_Error("An unknown error occurred (the server replied $Data)", "Unknown error: $Data");
		}
	}
	DPS_Disconnect();
	DPS_Status("Downloaded data",1);
	if($Raw) {
		if (defined($MainData) and length($MainData)) {
			return($MainData);
		} else {
			return(undef);
		}
	} else {
		return(1);
	}
}

# Purpose: Send data to a services server
# Usage: DPS_SendData();
sub DPS_SendData {
	my $Force = $_[0] ? 1 : 0;
	return unless DPS_Connect();
	DPS_Status("Sending data",0.5);
	my ($SendData, $RawMD5) = DPF_GetData(0,0,1,1,1);
	chomp($SendData);
	my $MD5 = md5_base64($SendData);
	my $ServerMD5 = DPS_DataSegment("GET_MD5");
	# Don't send the data if the checksums match
	if (not $ServerMD5 =~ /^(\[NONE\]|ERR)/ and $ServerMD5 eq $MD5) {
		DPS_Disconnect();
	} else {
	       	# Fail with an error if the checksums of $ServerMD5 and $InternalConfig{DPS_LastMD5} doesn't match
		if (not $ServerMD5 =~ /^(\[NONE\]|ERR)/ and not $ServerMD5 eq $InternalConfig{DPS_LastMD5}) {
			DPS_Disconnect();
			if(DPQuestion("An error occurred while uploading your data to the day planner services server.\n\nThe server has another version of the data. This can be repaired by Day Planner.\n\nDo you want Day Planner to try to repair this conflict?")) {
				return(0) unless DPS_RepairData();
				$InternalConfig{DPS_LastMD5} = $ServerMD5;
				return(0) unless DPS_Connect();
			} else {
				DPIntWarn("DPS: Failed to send due to an md5 mismatch and the user declined automatic repair");
				return(0);
			}
		}
		my $LastMD5 = $InternalConfig{DPS_LastMD5} ? $InternalConfig{DPS_LastMD5} : "undef";
		my $Reply = DPS_DataSegment("SENDDATA $MD5 $LastMD5 $SendData $Force");
		DPS_Disconnect();
		unless($Reply eq "OK") {
			if($Reply =~ s/^ERR\s+//) {
				DPS_Error("An error ocurred during uploading of the data", "Sending data failed: $Reply");
			} else {
				# Sending the data failed
				DPS_Error("The server did not accept my uploaded data and replied with an unknwown value: $Reply", "Sending data failed: $Reply");
			}
			return(undef);
		}
	}
	DPS_Status("Data sent",1);
	return(1);
}

# Purpose: Output an error occurring with DPS
# Usage: DPS_Error(User_Error, Technical_Error)
# 	User_Error is displayed as a pop-up error dialog.
# 	Technical_Error is DPIntWarn()ed
sub DPS_Error {
	my ($user_error, $tech_error) = @_;
	DPIntWarn("DPS: $tech_error");
	if(defined($user_error)) {
		$DPServices{Error} = $user_error;
	}
}

# Purpose: Wrapper around DPS functions setting stuff up correctly
# Usage: DPS_Perform(FUNCTION)
# 	Function can be one of:
# 	GET	- Get data from the server
# 	SEND	- Send data to the server
sub DPS_Perform {
	my $Function = $_[0];
	return unless(defined($InternalConfig{DPS_Enable}) and $InternalConfig{DPS_Enable} eq "1");
	return if(defined($ENV{DP_DISABLE_SERVICES}) and $ENV{DP_DISABLE_SERVICES} eq "1");
	# Verify that options are set
	foreach my $Option (qw(host port user pass)) {
		unless(defined($InternalConfig{"DPS_$Option"}) and length($InternalConfig{"DPS_$Option"})) {
			DPIntWarn("DPS enabled but the setting DPS_$Option is missing. DPS will not be used.");
			return(undef);
		} else {
			$DPServices{$Option} = $InternalConfig{"DPS_$Option"};
		}
	}
	if($Function eq "GET") {
		return(DPS_GetData());
	} elsif ($Function eq "SEND") {
		return(DPS_SendData());
	} elsif ($Function eq "GET_RAW") {
		return(DPS_GetData(1));
	} else {
		DPIntWarn("Invalid option to DPS_Perform: $Function. Ignoring");
		return(undef);
	}
}

# Purpose: Wrapper around DPS_Perform that creates the GUI widgets
# Usage: DPS_GUIPerform(FUNCTION)
# 	The FUNCTION argument is identical to DPS_Perform's FUNCTION argument
sub DPS_GUIPerform {
	my $Function = $_[0];
	return unless(defined($InternalConfig{DPS_Enable}) and $InternalConfig{DPS_Enable} eq "1");

	# Create the progress window
	$MainWindow->set_sensitive(0);
	$DPServices{ProgressWin} = DPCreateProgressWin("Services", "Initializing");

	my $Return = DPS_Perform($Function);
	$DPServices{ProgressWin}->{Window}->destroy();
	if(defined($DPServices{Error})) {
		DPError("An error ocurred with the day planner services:\n\n$DPServices{Error}");
		delete($DPServices{Error});
	}
	delete($DPServices{ProgressWar});
	$MainWindow->set_sensitive(1);
	return($Return);
}

# Purpose: Set the status in the DPS GUI Window
# Usage: DPS_Status(TEXT, COMPLETED);
# 	COMPLETED is a number between 0 and 1
# 	0 = 0%
# 	1 = 100%
sub DPS_Status {
	my ($Text, $Completed) = @_;
	return unless($Gtk2Init);
	if(defined($DPServices{ProgressWin})) {
		$DPServices{ProgressWin}->{ProgressBar}->set_fraction($Completed);
		$DPServices{ProgressWin}->{ProgressBar}->set_text($Text);
		Gtk2->main_iteration while Gtk2->events_pending;
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Data and configuration file functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Write a configuration file
# Usage: WriteConfigFile(/FILE, \%ConfigHash, \%ExplanationHash);
sub WriteConfigFile {
	my ($File, $Config, $Explanations) = @_;

	# Open the config for writing
	open(my $CONFIG, ">", "$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		DPIntWarn("Unable to save the configuration file $File: $!");
		return(0);
	};
	if(defined($Explanations->{HEADER})) {
		print $CONFIG "# $Explanations->{HEADER}\n";
	}
	foreach(sort(keys(%{$Config}))) {
		next unless length($Config->{$_});	# Don't write empty options
		if(defined($Explanations->{$_})) {
			print $CONFIG "\n# $Explanations->{$_}";
		}
		print $CONFIG "\n$_=$Config->{$_}\n";
	}
	close($CONFIG);
}

# Purpose: Load a configuration file
# Usage: LoadConfigFile(/FILE, \%ConfigHash, \%OptionRegexHash, OnlyValidOptions?);
#  OptionRegeXhash can be available for only a select few of the config options
#  or skipped completely (by replacing it by undef).
#  If OnlyValidOptions is true it will cause LoadConfigFile to skip options not in
#  the OptionRegexHash.
sub LoadConfigFile {
	my ($File, $ConfigHash, $OptionRegex, $OnlyValidOptions) = @_;

	open(my $CONFIG, "<", "$File") or do {
		DPError($Gettext->get(sprintf("Unable to read the configuration settings from %s: %s", $File, $!)));
		return(0);
	};
	while(<$CONFIG>) {
		next if m/^\s*(#.*)?$/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		if($OnlyValidOptions) {
			unless(defined($OptionRegex->{$Option})) {
				DPIntWarn("Unknown configuration option \"$Option\" in $File: Ignored.");
				next;
			}
		}
		unless(defined($Value)) {
			DPIntWarn("Empty value for option $Option in $File");
		}
		if(defined($OptionRegex) and defined($OptionRegex->{$Option})) {
			my $MustMatch = $OptionRegex->{$Option};
			unless ($Value =~ /$MustMatch/) {
				print "Invalid setting of $Option in the config file: Must match $OptionRegex->{Option}.\n";
				next;
			}
		}
		$ConfigHash->{$Option} = $Value;
	}
	close($CONFIG);
}

# Purpose: Write the state file 
# Usage: WriteStateFile(DIRECTORY, FILENAME);
sub WriteStateFile {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];

	my $NewWinState = 1;

	my %Explenations = (
		MainWin_Maximized => "If the main window is maximized or not (0=false, 1=true)",
		MainWin_Width => "The width of the main window",
		MainWin_Height => "The height of the main window",
		AutostartOn => "If the preferences setting for autostarting the daemon on login is on or not",
		AddedAutostart => "If day planner has (automatically) set the daemon to start on login\n# (this ONLY sets if it has been automatically added or not.\n# It doesn't say anything about IF it is currently added. AutostartOn sets that.)",
		Holiday_Attempted => "The last day planner version the holiday file was attempted set up (but failed)",
		Holiday_Setup => "If the holiday file has been properly set up or not (ie. not a dummy file)",
		DPS_Enable => "If DPS (Day Planner servies) is enabled or not (1/0)",
		DPS_LastMD5 => "The MD5 sum of the last data downloaded from the DPS server (base64 encoded)",
		DPS_host => "The DPS host to connect to",
		DPS_pass => "The password",
		DPS_port => "The port to connect to on the DPS server",
		DPS_user => "The username",
		HEADER => "This file contains internal configuration used by day planner\n# In most cases you really don't want to edit this file manually",
	);

	
	if(defined($InternalConfig{MainWin_Maximized}) and $InternalConfig{MainWin_Maximized} =~ /maximized/) {
		$InternalConfig{MainWin_Maximized} = 1;
	} else {
		$InternalConfig{MainWin_Maximized} = 0;
		if($NewWinState) {
			($InternalConfig{MainWin_Width}, $InternalConfig{MainWin_Height}) = $MainWindow->get_size();
		}
	}
	
	# Write the actual file
	WriteConfigFile("$Dir/$File", \%InternalConfig, \%Explenations);
}

# Purpose: Load the state file
# Usage: LoadStateFile(DIRECTORY, FILENAME);
sub LoadStateFile {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];
	if(-e "$Dir/$File") {
		LoadConfigFile("$Dir/$File", \%InternalConfig, undef, 0);
	}
}

# Purpose: Write the configuration file
# Usage: WriteConfig(DIRECTORY, FILENAME);
sub WriteConfig {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];
	# Verify the options first
	unless(defined($UserConfig{EditorVerboseDefault}) and length($UserConfig{EditorVerboseDefault})) {
		$UserConfig{EditorVerboseDefault} = 0;
	}
	unless(defined($UserConfig{Events_NotifyPre}) and length($UserConfig{Events_NotifyPre})) {
		$UserConfig{Events_NotifyPre} = "30min";
	}
	unless(defined($UserConfig{Events_DayNotify}) and length($UserConfig{Events_DayNotify})) {
		$UserConfig{Events_DayNotify} = 0;
	}
	my %Explanations = (
		EditorVerboseDefault => "If the EventEditor should expand the \"details\" by default\n#  1 = expand\n#  0 = don't expand",
		Events_NotifyPre => "If day planner should notify about an event ahead of time.\n#  0 = Don't notify\n# Other valid values: 10min, 20min, 30min, 45min, 1hr, 2hrs, 4hrs, 6hrs",
		Events_DayNotify => "If day planner should notify about an event one day before it occurs.\n#  0 - Don't notify one day in advance\n#  1 - Do notify one day in advance",
		HEADER => "Day planner $Version configuration file",
	);
	
	# Write the actual file
	WriteConfigFile("$Dir/$File", \%UserConfig, \%Explanations);

	# Tell the daemon to reload the config file
	if($DaemonInitialized) {
		unless(Daemon_DataSegment("RELOAD_CONFIG") eq "done\n") {
			# TODO: GUI dialog?
			DPIntWarn("Failed to tell the daemon to reload its configuration file. This might cause problems");
		}
	}
}

# Purpose: Load the configuration file
# Usage: LoadConfig(DIRECTORY, FILENAME);
sub LoadConfig {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];
	# If it doesn't exist then we just let WriteConfig handle it
	unless (-e "$Dir/$File") {
		WriteConfig($Dir, $File);
		return(1);
	}
	
	my %OptionRegexHash = (
			EditorVerboseDefault => '^\d+$',
			Events_NotifyPre => '^(\d+(min|hrs?){1}|0){1}$',
			Events_DayNotify => '^\d+$',
		);

	LoadConfigFile("$Dir/$File", \%UserConfig, \%OptionRegexHash);
	return(1);
}

# Purpose: Load the default configuration file
# Usage: LoadDefaultConfig();
sub LoadDefaultConfig {
	return(LoadConfig($SaveToDir, $ConfigFile));
}

# Purpose: Save the default configuration file
# Usage: SaveDefaultConfig();
sub SaveDefaultConfig {
	return(WriteConfig($SaveToDir, $ConfigFile));
}

# Purpose: Create the directory in $SaveToDir if it doesn't exist and display a error if it fails
# Usage: CreateSaveDir();
sub CreateSaveDir {
	unless (-e $SaveToDir) {
		mkdir($SaveToDir) or do {
				DPError($Gettext->get(sprintf("Unable to create the directory %s: %s\nManually create this directory before closing this dialog.", $SaveToDir, $!)));
				unless(-d $SaveToDir) {
					die("$SaveToDir does not exist, I was unable to create it and the user didn't create it\n");
				}
			}
	}
}

# Purpose: Perform certain commands on first startup
# Usage: FirstStartup(MIGRATE?);
sub FirstStartup {
	# First create the savedir
	CreateSaveDir();
	# Now try to migrate plan data
	MigratePlan(1) unless $_[0];
}	

# Purpose: Save the datafile
# Usage: SaveDatafile(DIRECTORY, FILENAME, HashRef to save, Name of the hash);
sub SaveDatafile {
	my($Directory, $Filename, $SaveHash, $HashName, $ProgressBar) = @_;
	my $SAVEFILE;
	# We want the dumper to be pure (aka. make dumper output a proper syntax that is suitable for eval() or do())
	$Data::Dumper::Purity = 1;
	# Sort the keys
	$Data::Dumper::Sortkeys = 1;
	# Set the indentation
	$Data::Dumper::Indent = 1;
	# Pulse once
	PulsateProgressbar($ProgressBar);
	# Create the save directory
	CreateSaveDir();
	# Pulse once
	PulsateProgressbar($ProgressBar);
	# Open the savefile ($_[0]/$_[1]) for writing
	open($SAVEFILE, ">", "$_[0]/$_[1]") or do {
		# EMERGENCY FALLBACK
		
		# Okay, we couldn't open it. This is bad.
		# Now we try to detect a directory to fall back to.
		my $FallbackDirectory;
		my $Error = $!;
		my $FallbackFailed = 1;
		# Try to find a directory we can use
		foreach my $Fallback (@SaveFallbackDirs) {
			PulsateProgressbar($ProgressBar);
			if (-e $Fallback and -w $Fallback) {
				if (-e "$Fallback/$_[1]" and ! -w "$Fallback/$_[1]") {
					next;
				}
				$FallbackDirectory = $Fallback;
				last;
			}
		}
		# If $FallbackDirectory is true then display the error and try to open the fallback
		if ($FallbackDirectory) {
			DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$_[0]/$_[1]", $Error, "$FallbackDirectory/$_[1]"));
			$FallbackFailed = 0;
			open($SAVEFILE, ">", "$FallbackDirectory/$_[1]") or $FallbackFailed = 1;
		} 
		# If FallbackDirectory failed or we didn't find one - output to STDOUT
		if ($FallbackFailed) {
			if ($FallbackDirectory) {	# If $FallbackDirectory was attempted but failed then display this
				DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$FallbackDirectory/$_[1]", $Error, "STDOUT"));
			} else {			# If $FallbackDirectory wasn't possible, display this
				DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$_[0]/$_[1]", $Error, "$FallbackDirectory/$_[1]"));
			}
			print STDOUT Dumper(\%CalendarContents);
			# By returning 0 we tell the caller that something went very wrong and that we
			# might not want to quit if that's what we're doing.
			return(0);
		}
	};
	# Print this
	print $SAVEFILE "# Day Planner data file for day planner version $Version\n";
	print $SAVEFILE "# Last saved on: ", scalar(localtime),"\n";
	print $SAVEFILE "#\n# The format is explained in doc/SaveformatSyntax\n";
	# Pulse once
	PulsateProgressbar($ProgressBar);
	# Dump the data
	print $SAVEFILE Data::Dumper->Dump([$_[2]], ["*$_[3]"]);
	# Pulse once and close
	PulsateProgressbar($ProgressBar);
	close($SAVEFILE);
	# We successfully saved the data
	return(1);
}

# Purpose: Save the main data files
# Usage: SaveMainData();
sub SaveMainData {
	my($ProgressWin, $ProgressBar);
	if($Gtk2Init) {
		my $ProgressBarWin = DPCreateProgressWin($Gettext->get("Saving..."), undef, 1);
		$ProgressWin = $ProgressBarWin->{Window};
		$ProgressBar = $ProgressBarWin->{ProgressBar};
	}

	my $Return = 'OKAY';
	unless(SaveDatafile($SaveToDir, $MainEventsFile, \%CalendarContents, "CalendarContents", $ProgressBar)) {
		$Return	= 'SAVE_FAILED';
	}
	unless(SaveDatafile($SaveToDir, $SpecialEventsFile, \%SpecialEvents, "SpecialEvents", $ProgressBar)) {
		$Return = 'SAVE_FAILED';
	}
	unless(SaveDatafile($SaveToDir, $BirthdayFile, \%BirthdayContents, "BirthdayContents", $ProgressBar)) {
		$Return = 'SAVE_FAILED';
	}
	$ProgressWin->destroy() if($Gtk2Init);
	# This to avoid unneccesary overhead in the daemon reloading files needlessly
	unless(Daemon_DataSegment("RELOAD_DATA") eq "done\n") {
		if($Gtk2Init) {
			DPWarning($Gettext->get("<b><big>Day planner encountered an error while saving events</big></b>.\n\nThere appears to be another instance of day planner running. This may lead to data loss.\n\nLeaving this instance of Day Planner open while you resolve the issues with the other instance of Day Planner will ensure your data remains safe. Closing this instance of Day Planner before it can safely write recent changes will result in data loss."));
		} else {
			DPWarning("Unable to tell the daemon to reload its data. This *could* be bad.");
		}
		if ($Return eq 'OKAY') {
			$Return = 'DAEMON_RELOAD_FAILURE';
		}
	}
	return($Return);
}

# Purpose: Save the data file and redraw the needed windows
# Usage: UpdatedData();
sub UpdatedData {
	# Save the data
	SaveMainData();
	# Redraw the event list
	DrawEventlist();
	# Repopulate the upcoming events
	PopulateUpcomingEvents();
	# Redraw the calendar
	CalendarChange();
}

# Purpose: Load the calendar contents
# Usage: LoadCalendar();
sub LoadCalendar {
	if(DataLoadTest("$SaveToDir/$MainEventsFile")) {
		%CalendarContents = do("$SaveToDir/$MainEventsFile");
	}
	if(DataLoadTest("$SaveToDir/$BirthdayFile")) {
		%BirthdayContents = do("$SaveToDir/$BirthdayFile");
	}
	if(DataLoadTest("$SaveToDir/$SpecialEventsFile")) {
		%SpecialEvents = do("$SaveToDir/$SpecialEventsFile");
	}
	if(DataLoadTest("$SaveToDir/$AllDayEventsFile")) {
		%AllDayEvents = do("$SaveToDir/$AllDayEventsFile");
	}
	return(1);
}

# Purpose: Test if a load can be successfully performed of the supplied file
# Usage: DataLoadTest("/path/to/file");
sub DataLoadTest {
	# If the calendar savefile exists
	if (-e "$_[0]") {
		# If it isn't readable then we warn and return
		unless (-r "$_[0]") {
			DPIntWarn("Unable to read the calendar at $_[0]: It isn't readable by me");
			return(0);
		}
		# If it isn't writeable then we just warn (the file can still be loaded)
		unless (-w "$_[0]") {
			DPIntWarn("Unable to write the calendar at $_[0]: It isn't writeable by me. Expect trouble!");
		}
		return(1);
	} else {
		# If the file doesn't exist then we just assume that it isn't created yet,
		# so we return false, but do it silently.
		return(0);
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Core helper functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Append a "0" to a number if it is only one digit.
# Usage: my $NewNumber = AppendZero(NUMBER);
sub AppendZero {
	if ($_[0] =~ /^\d$/) {
		return("0$_[0]");
	}
	return($_[0]);
}

# Purpose: Get OS/distro version information
# Usage: print "OS: ",GetDistVer(),"\n";
sub GetDistVer {
	# GNU/Linux and BSD
	foreach(qw/mandriva mandrakelinux mandrake fedora redhat red-hat ubuntu lsb debian gentoo suse distro dist slackware freebsd openbsd netbsd dragonflybsd NULL/) {
		if (-e "/etc/$_-release" or -e "/etc/$_-version" or -e "/etc/${_}_version" or $_ eq "NULL") {
			my ($DistVer, $File, $VERSION_FILE);
			if(-e "/etc/$_-release") {
				$File = "$_-release";
				open($VERSION_FILE, "<", "/etc/$_-release");
				$DistVer = <$VERSION_FILE>;
			} elsif (-e "/etc/$_-version") {
				$File = "$_-version";
				open($VERSION_FILE, "<", "/etc/$_-release");
				$DistVer = <$VERSION_FILE>;
			} elsif (-e "/etc/${_}_version") {
				$File = "${_}_version";
				open($VERSION_FILE, "<", "/etc/${_}_version");
				$DistVer = <$VERSION_FILE>;
			} elsif ($_ eq "NULL") {
				last unless -e "/etc/version";
				$File = 'version';
				open($VERSION_FILE, "<", "/etc/version");
				$DistVer = <$VERSION_FILE>;
			}
			close($VERSION_FILE);
			chomp($DistVer);
			return("/etc/$File: $DistVer");
		}
	}
	# Didn't find anything yet. Get uname info
	my ($sysname, $nodename, $release, $version, $machine) = POSIX::uname();
	if ($sysname =~ /darwin/i) {
		my $DarwinName;
		my $DarwinOSVer;
		# Darwin kernel, try to get OS X info.
		if(InPath("sw_vers")) {
			if(open(my $SW_VERS, "sw_vers |")) {
				while(<$SW_VERS>) {
					chomp;
					if (s/^ProductName:\s+//gi) {
						$DarwinName = $_;
					} elsif(s/^ProductVersion:\s+//) {
						$DarwinOSVer = $_;
					}
				}
				close($SW_VERS);
			}
		}
		if(defined($DarwinOSVer) and defined($DarwinName)) {
			return("$DarwinName $DarwinOSVer ($machine)");
		}
	}
	return("Unknown ($sysname $release $version $machine)");
}

# Purpose: Print a warning to STDERR with proper output
# Usage: DPIntWarn("Warning");
sub DPIntWarn {
	warn "*** (Day Planner $Version) Warning: $_[0]\n";
}

# Purpose: Delete keys from %CalendarContents, recusively if needed
# Usage: CalendarDelete(year,month,day,time);
sub CalendarDelete {
	my ($EventYear,$EventMonth,$EventDay,$EventTime) = @_;
	unless(CalendarDefined(@_)) {
		DPIntWarn("CalendarDelete: Unable to find an event at $EventYear/$EventMonth/$EventDay/$EventTime");
		return(undef);
	}
	delete($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime});
		unless (keys(%{$CalendarContents{$EventYear}{$EventMonth}{$EventDay}})) {
			delete($CalendarContents{$EventYear}{$EventMonth}{$EventDay});
				unless (keys(%{$CalendarContents{$EventYear}{$EventMonth}})) {
					delete($CalendarContents{$EventYear}{$EventMonth});
						unless(keys(%{$CalendarContents{$EventYear}})) {
							delete($CalendarContents{$EventYear});
						}
			}
	}
}

# Purpose: Delete keys from %BirthdayContents, recusively if needed
# Usage: BirthdayDelete(month,day,name);
sub BirthdayDelete {
	my ($EventMonth,$EventDay,$Name) = @_;
	unless(BirthdayDefined(@_)) {
		DPIntWarn("BirthdayDelete: Unable to find an event at $EventMonth/$EventDay/$Name");
		return(undef);
	}
	delete($BirthdayContents{$EventMonth}{$EventDay}{$Name});
		unless (keys(%{$BirthdayContents{$EventMonth}{$EventDay}})) {
			delete($BirthdayContents{$EventMonth}{$EventDay});
				unless (keys(%{$BirthdayContents{$EventMonth}})) {
					delete($BirthdayContents{$EventMonth});
			}
	}
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Recursively test for defined data in %CalendarContents
# 		If a single test is run then invalid data might get inserted into %CalendarContents
# 		this avoids that by doing a recursive test
# Usage: CalendarDefined(year,month,day,time);
sub CalendarDefined {
	my ($EventYear,$EventMonth,$EventDay,$EventTime,$EventType) = @_;
	if(defined($CalendarContents{$EventYear}) and defined($CalendarContents{$EventYear}{$EventMonth}) and defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}) and defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime})) {
			return(1)
		}
	return(0);
}

# Purpose: Recursively test for defined data in %BirthdayContents
# 		If a single test is run then invalid data might get inserted into %BirthdayContents
# 		this avoids that by doing a recursive test
# Usage: BirthdayDefined(month,day,summary);
sub BirthdayDefined {
	my ($EventMonth, $EventDay, $EventSummary) = @_;
	if(defined($BirthdayContents{$EventMonth}) and defined($BirthdayContents{$EventMonth}{$EventDay}) and defined($BirthdayContents{$EventMonth}{$EventDay}{$EventSummary})) {
			return(1)
		}
	return(0);
}

# Purpose: Recursively test for defined data in %CalendarContents
# 		If a single test is run then invalid data might get inserted into %CalendarContents
# 		this avoids that by doing a recursive test
# Usage: CalendarDayDefined(year,month,day);
sub CalendarDayDefined {
	my ($EventYear,$EventMonth,$EventDay,$EventTime,$EventType) = @_;
	if(defined($CalendarContents{$EventYear}) and defined($CalendarContents{$EventYear}{$EventMonth}) and defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay})) {
			return(1)
		}
	return(0);
}

# Purpose: Recursively test for defined data in %BirthdayContents
# 		If a single test is run then invalid data might get inserted into %BirthdayContents
# 		this avoids that by doing a recursive test
# Usage: BirthdayDayDefined(month,day);
sub BirthdayDayDefined {
	my ($EventMonth, $EventDay, $EventSummary) = @_;
	if(defined($BirthdayContents{$EventMonth}) and defined($BirthdayContents{$EventMonth}{$EventDay})) {
			return(1)
		}
	return(0);
}

# Purpose: Handle various signals gracefully
# Usage: $SIG{SIGNAL} = \&DP_SigHandler;
sub DP_SigHandler {
	$| = 1;
	print "SIG$_[0] recieved.\nSaving data...";
	if(SaveMainData() eq "SAVE_FAILED") {
		print "FAILED";
	} else {
		print "done";
	}
	print "\nWriting state file...";
	WriteStateFile($SaveToDir, "state.conf");
	print "done\nExiting the gtk2 main loop...";
	Gtk2->main_quit;
	print "done\nClosing the daemon connection...";
	CloseDaemon();
	print "done\nExiting\n";
	exit(0);
}

# Purpose: Make sure we have a .holiday set up
# Usage: HolidaySetup();
sub HolidaySetup {
	# If Holiday_Setup is true and the file exists then day planner has properly set up
	# a holiday-file.
	#
	# If Holiday_Attempted is defined and equal to $Version then we've attempted and failed
	# to set up a holiday file in this version of day planner so we'll skip trying again.
	if($InternalConfig{Holiday_Setup} and -e $HolidayFile) {
		return(1);
	} elsif(defined($InternalConfig{Holiday_Attempted}) and $InternalConfig{Holiday_Attempted} eq $Version) {
		return(1);
	}
	# Hash of LC_ADDRESS code => holiday file
	my %HolidayFiles = (
		"nb" => "norway",	# Norway
		"nn" => "norway",	# Norway
		"no" => "norway",	# Norway
		"en_US" => "us",	# USA
		"us" => "us",		# USA
		"en_UK" => "uk",	# The UK
		"uk" => "uk",		# The UK
		"sv" => "swedish",	# Sweden
		"fr" => "french",	# France
		"it" => "italy",	# Italy
		"el_GR" => "greek",	# Greece
		"cs_CZ" => "czech",	# Czech
		"da_DK" => "denmark",	# Denmark
		"nl_NL" => "dutch",	# The Netherlands
		"fi_FI" => "finnish",	# Finland
		"de_DE" => "german",	# Germany
		"hu_HU" => "hungary",	# Hungary
		"ja_JP" => "japan",	# Japan
		"pt_PT" => "portugal",	# Portugal
		"sk_SK" => "slovak",	# Slovakia
		"es_ES" => "spain",	# Spain
		"en_CA" => "canada",	# Canada
	);
	# Yay, the user already has a .holiday file. Use this one
	if(-e "$ENV{HOME}/.holiday") {
		symlink("$ENV{HOME}/.holiday",$HolidayFile);
		$InternalConfig{Holiday_Setup} = 1; delete($InternalConfig{Holiday_Attempted}) if defined($InternalConfig{Holiday_Attempted});
		return(1);
	}


	my $LocationDetect;

	if(defined($ENV{LC_ADDRESS})) {
		$LocationDetect = $ENV{LC_ADDRESS};
	} elsif (defined($ENV{LC_TELEPHONE})) {
		$LocationDetect = $ENV{LC_TELEPHONE};
	} elsif (defined($ENV{LC_IDENTIFICATION})) {
		$LocationDetect = $ENV{LC_IDENTIFICATION};
	} elsif (defined($ENV{LC_MESSAGES})) {
		$LocationDetect = $ENV{LC_MESSAGES};
	} elsif (defined($ENV{LC_ALL})) {
		$LocationDetect = $ENV{LC_ALL};
	} elsif (defined($ENV{LANGUAGE})) {
		$LocationDetect = $ENV{LANGUAGE};
	} else {
		DPIntWarn("Neither of the environment variables LC_ADDRESS, LC_TELEPHONE, LC_IDENTIFICATION, LC_MESSAGES, LC_ALL nor LANGUAGE was set. Unable to autodetect .holiday file");
	}

	my $CopyFile;
	
	if(defined($LocationDetect)) {
		# Let's try to find the users LC_ADDRESS in the %HolidayFiles hash
		# We sort it so that we test the longest entries before testing the short ones
		foreach my $Key (sort {length($b) <=> length($a)} keys(%HolidayFiles)) {
			if($LocationDetect =~ /^$Key/) {
			$CopyFile = $HolidayFiles{$Key};
					last;
			}
		}
		if(defined($CopyFile)) {
			if(-e "$FindBin::RealBin/holiday/holiday_$CopyFile") {
				copy("$FindBin::RealBin/holiday/holiday_$CopyFile", $HolidayFile);
				$InternalConfig{Holiday_Setup} = 1; delete($InternalConfig{Holiday_Attempted}) if defined($InternalConfig{Holiday_Attempted});
				return(1);
			} else {
				DPIntWarn("The .holiday file detected for you (holiday_$CopyFile at $FindBin::RealBin/holiday/holiday_$CopyFile) did not exist.");
			}
		} else {
			DPIntWarn("Couldn't detect a .holiday file for $LocationDetect. Maybe you would like to write one?");
		}
	}
	open(my $DUMMY_FILE, ">", "$HolidayFile");
	print $DUMMY_FILE ": This is a dummy .holiday file for day planner. It couldn't detect a proper\n";
	print $DUMMY_FILE ": one suitable for your location (which at the time was detected to be $LocationDetect).\n";
	print $DUMMY_FILE ": You may want to write one yourself (see the files contained in the holiday/ directory\n";
	print $DUMMY_FILE ":  of the day planner distribution for examples of the syntax).\n";
	print $DUMMY_FILE "\n: HOW TO REPLACE THE DUMMY FILE WITH A PROPER ONE:\n: Remove this file, copy the proper file to ~/.holiday and re-run day planner";
	close($DUMMY_FILE);
	$InternalConfig{Holiday_Setup} = 0;
	$InternalConfig{Holiday_Attempted} = $Version;
	return(0);
}

# Purpose: Remove the daemon from autostart for the various DMs/WMs
# Usage: RemoveAutostart();
sub RemoveAutostart {
	# KDE, XDG and XFCE4 - easy
	foreach("$ENV{HOME}/.kde/Autostart/dayplanner_auto.sh", "$ENV{HOME}/.config/autostart/dayplanner_auto.desktop", "$ENV{HOME}/Desktop/Autostart/dayplanner_auto.sh") {
		unlink($_) if -e $_;
	}

	# Fluxbox
	if(-w "$ENV{HOME}/.fluxbox/startup") {
		my @FluxboxStartup;
		open(my $OLDFLUX, "<", "$ENV{HOME}/.fluxbox/startup");
		push(@FluxboxStartup, $_) while(<$OLDFLUX>);
		close($OLDFLUX);
		open(my $FLUXSTART, ">", "$ENV{HOME}/.fluxbox/startup");
		foreach(@FluxboxStartup) {
			unless(/$DaemonName/) {
				chomp;
				print $FLUXSTART "$_\n";
			}
		}
		close($FLUXSTART);
	}
	# GNOME 2 versions 2.12 and older.
	#  This solution is very very hacky and unreliable, but it will have to do.
	if(-w "$ENV{HOME}/.gnome2/session-manual") {
		my @Gnome2Session;
		my $GNOME2SESS;
		open($GNOME2SESS, "<", "$ENV{HOME}/.gnome2/session-manual");
		push(@Gnome2Session, $_) while(<$GNOME2SESS>);
		close($GNOME2SESS);
		my ($Last, $Has_DP, $DP_ID, $Nullout);
		# Parse
		foreach(@Gnome2Session) {
			next unless /\=/;
			next unless /^\d,/;
			my $ID = $_;
			$ID =~ s/^(\d+).*/$1/;
			if(/$DaemonName/) {
				$DP_ID = $ID;
				$Has_DP = 1;
			}
			$Last = $ID;
			# Make sure we're not starting on yet another session.
			if($ID == 0) {
				# GAH, another session decleration. This is too much for us to parse.
				# Use the alternate nullout method (continue attempting to parse if Has_DP is
				# false
				$Nullout = 1;
				last if $Has_DP;
			}
		}
		
		# We've got three ways to do this, one more hacky than the next - but
		# as gnome2 (2.12 and older) doesn't have any good way of dealing with
		# this we'll have to do this.
		if($Has_DP) {
			if($Last == 0) {
				# Wee, LAST is 0, just 0 out the file
				open($GNOME2SESS, ">", "$ENV{HOME}/.gnome2/session-manual");
				close($GNOME2SESS);
			} elsif($Nullout) {
				DPIntWarn("Unable to properly remove the GNOME2 day planner entry from $ENV{HOME}/.gnome2/session-manual. A workaround to disable the daemon startup has been applied but you may want to use the GNOME2 session manager to remove it completely.");
				foreach(@Gnome2Session) {
					s/=.*$DaemonName.*/perl -e '# Removed by day planner'/;
				}
				open($GNOME2SESS, ">", "$ENV{HOME}/.gnome2/session-manual");
				foreach(@Gnome2Session) {
					print $GNOME2SESS $_;
				}
				close($GNOME2SESS);
			} else {
				my $NumClients = $Last + 1;
				# Write out changes
				open($GNOME2SESS, ">", "$ENV{HOME}/.gnome2/session-manual");
				foreach(@Gnome2Session) {
					chomp;
					s/^num_clients=\d+/num_clients=$Last/;
					s/^$Last,/$DP_ID,/;
					next if /^$DP_ID,/;
					print $GNOME2SESS "$_\n";
				}
				close($GNOME2SESS);
			}
		}
	}
	return(1);
}

# Purpose: Add the daemon to autostart for the various DMs/WMs
# Usage: AddAutostart(OLD_GNOME?);
# 	OLD_GNOME is either 1 or 0, defines if the GNOME version used is
# 	older than 2.13 or not
sub AddAutostart {
	my $TryGnome = $_[0];
	my $DaemonExec;
	my $RETURN = "okay";
	foreach(split(/:/, sprintf("%s:%s", dirname(Cwd::realpath($0)), $ENV{PATH} ))) {
		if (-x "$_/$DaemonName") {
			$DaemonExec = "$_/$DaemonName";
			last;
		}
	}
	die("Unable to detect the daemon") unless(defined($DaemonExec));

	# KDE - this is easy
	if(-d "$ENV{HOME}/.kde/") {
		mkdir("$ENV{HOME}/.kde/Autostart/") unless -e "$ENV{HOME}/.kde/Autostart/";
		open(my $KDESCRIPT, ">", "$ENV{HOME}/.kde/Autostart/dayplanner_auto.sh");
		print $KDESCRIPT "#!/bin/sh\n# Autogenerated startup script written by day planner\n";
		print $KDESCRIPT "$DaemonExec\n";
		close($KDESCRIPT);
	}
	# Freedesktop spec - this is easy too
	if(-d "$ENV{HOME}/.config/") {
		mkdir("$ENV{HOME}/.config/autostart/") unless -e "$ENV{HOME}/.config/autostart";
		open(my $XDGSTART, ">", "$ENV{HOME}/.config/autostart/dayplanner_auto.desktop");
		print $XDGSTART "# Autogenerated startup desktop file written by day planner\n";
		print $XDGSTART "[DESKTOP ENTRY]\n";
		print $XDGSTART "Type=Application\n";
		print $XDGSTART "Name=Day planner daemon autostart\n";
		print $XDGSTART "Comment=Automatically start the day planner daemon on session startup\n";
		print $XDGSTART "Exec=$DaemonExec\n";
		print $XDGSTART "StartupNotify=false\n";
		print $XDGSTART "StartupWMClass=fales\n";
		close($XDGSTART);
	}
	# GNOME - this is harder. No real common spec or easy way to do it. 2.14 or so
	#  supports the freedesktop spec, older however - does not.
	if(-d "$ENV{HOME}/.gnome2/" and $TryGnome) {
		# If it doesn't exist then we just write it
		unless(-e "$ENV{HOME}/.gnome2/session-manual") {
			open(my $GNOMESESS, ">", "$ENV{HOME}/.gnome2/session-manual");
			print $GNOMESESS "[Default]\nnum_clients=1\n0,RestartStyleHint=3\n0,Priority=50\n0,RestartCommand=$DaemonExec\n0,Program=$DaemonExec";
			close($GNOMESESS);
		} else {
			$RETURN = "gnome-fail";
			my @G2H;
			open(my $GNOMESESS, "<", "$ENV{HOME}/.gnome2/session-manual");
			while(<$GNOMESESS>) {
				if(s/perl -e '# Removed by day planner'/$DaemonExec/i) {
					$RETURN = "okay";
				}
				push(@G2H, $_);
			}
			close($GNOMESESS);
			if($RETURN eq "okay") {
				open($GNOMESESS, ">", "$ENV{HOME}/.gnome2/session-manual");
				print $GNOMESESS $_ foreach(@G2H);
				close($GNOMESESS);
			}
		}
	}
	# XFce 4
	if(-d "$ENV{HOME}/.config/xfce4/" and -d "$ENV{HOME}/Desktop/") {
		mkdir("$ENV{HOME}/Desktop/Autostart") unless -e "$ENV{HOME}/Desktop/Autostart";
		open(my $XFCESCRIPT, ">", "$ENV{HOME}/Desktop/Autostart/dayplanner_auto.sh");
		print $XFCESCRIPT "#!/bin/sh\n# Autogenerated startup script written by day planner\n";
		print $XFCESCRIPT "$DaemonExec\n";
		close($XFCESCRIPT);
	}
	# Fluxbox
	if(-d "$ENV{HOME}/.fluxbox") {
		my @FluxboxStartup;
		push(@FluxboxStartup, "$DaemonExec &");
		if(-e "$ENV{HOME}/.fluxbox/startup") {
			open(my $OLDFLUX, "<", "$ENV{HOME}/.fluxbox/startup");
			push(@FluxboxStartup, $_) while(<$OLDFLUX>);
			close($OLDFLUX);
		}
		open(my $FLUXSTART, ">", "$ENV{HOME}/.fluxbox/startup");
		foreach(@FluxboxStartup) {
			chomp;
			print $FLUXSTART "$_\n";
		}
		close($FLUXSTART);
	}
	return($RETURN);
}

# Purpose: Get the number of *milli*seconds until midnight
# Usage: my $miliseconds = MilisecondsUntilMidnight();
sub MilisecondsUntilMidnight {
	my ($currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst) = localtime(time);
	# Convert hours to seconds
	$currhour = $currhour * 60 * 60;
	# Minutes to seconds
	$currmin = $currmin * 60;

	my $SecondsInADay = 86_400;
	my $total = $SecondsInADay - ($currhour + ($currmin + $currsec));
	return($total*1000);
}

# Purpose: Repopulate the UpcomingEvents widget on a timer (every 24h)
# Usage: \&Day_Changed_Event;
sub Day_Changed_Event {
	# First repopulate the upcoming events widget
	PopulateUpcomingEvents();
	# Now reset the timer
	Set_DayChangeTimer();
	# Return false to make Glib remove the old timer
	return(0);
}

# Purpose: Set the day-changed timer
# Usage: Set_DayChangeTimer();
sub Set_DayChangeTimer {
	# Set the timer
	Glib::Timeout->add(MilisecondsUntilMidnight(), \&Day_Changed_Event);
}

# Purpose: Call the main initialization functions
# Usage: MainInit();
sub MainInit {
	my $NoGui = $_[0];
	# Set SaveToDir and HolidayFile
	$SaveToDir = "$ENV{HOME}/.dayplanner" unless(defined($SaveToDir));	# The configuration and eventlist directory
	$HolidayFile = "$SaveToDir/holidays";					# The file to load holiday definitions from

	FirstStartup($NoGui) unless -d $SaveToDir;

	# Load the configuration file
	LoadDefaultConfig();
	# Load the internal state file
	LoadStateFile($SaveToDir, "state.conf");
	# Load the calendar
	LoadCalendar();
	# Set up holidays
	HolidaySetup();
}

# Purpose: Convert AM/PM to internal 24H time
# Usage: AMPM_To24(TIME [AM|PM]);
sub AMPM_To24 {
	my ($Time, $MultiRet) = @_;
	return($Time) if $ClockSystem eq "24";
	my $Hour = $Time;
	my $Minutes = $Time;
	my $Suffix = $Time;
	$Hour =~ s/^(\d+):.*$/$1/;
	$Minutes =~ s/^\d+:(\d+).*$/$1/;
	$Suffix =~ s/^\d+:\d+\s+(.+)/$1/;
	if($Suffix eq $PM_String) {
		$Hour = $Hour+12;
	} elsif($Suffix eq $AM_String) {
		if($Hour == 12) {
			$Hour = "00";
		}
	}
	if($MultiRet) {
		return($Hour, $Minutes);
	} else {
		return("$Hour:$Minutes");
	}
}

# Purpose: Convert internal 24H time to AM/PM
# Usage: AM_PM_From24(TIME);
sub AMPM_From24 {
	my $Time = $_[0];
	return($Time) if $ClockSystem eq "24";
	my $Hour = $Time;
	my $Minutes = $Time;
	my $Suffix;
	$Hour =~ s/^(\d+):.*$/$1/;
	$Minutes =~ s/^\d+:(\d+).*$/$1/;
	if($Hour >= 12) {
		$Suffix = $PM_String;
		$Hour = $Hour-12;
	}
	unless(defined($Suffix)) {
		if($Hour == 0) {
			$Hour = "12";
		}
		$Suffix = $AM_String;
	}
	return("$Hour:$Minutes $Suffix");
}

# =============================================================================
# IMPORT/EXPORT
# =============================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Various utility functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Resolve a conflict during an import
# Usage: my (message, newtime) = Import_ResolveConflict(Year,Month,Day,Time,summary,fulltext);
sub Import_ResolveConflict {
	my($Year,$Month,$Day,$Time,$summary,$fulltext) = @_;
	my($Attempts,$ConflictMessage,$Conflict);
	my $OrigTime = $Time;
	while(CalendarDefined($Year, $Month, $Day, $Time)) {
		my $ThisConflicted;
		$Attempts++;
		my $Hour = $Time;
		my $Min = $Time;
		$Hour =~ s/^(\d+):.*$/$1/;
		$Min =~ s/^\d+:(\d+)$/$1/;
		if($Attempts > 19) {
			$Time = undef;
			DPIntWarn("Unable to resolve \"$summary\" at $Day.$Month.$Year $OrigTime - would move the event more than 20 minutes.");
			$Conflict = 1;
			last;
		}
		if($summary eq $CalendarContents{$Year}{$Month}{$Day}{$Time}{summary}) {
			if(defined($fulltext) and defined($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext})) {
				unless($fulltext eq $CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext}) {
					$ThisConflicted = 1;
				}
			}
		} else {
			$ThisConflicted = 1;
		}
		if($ThisConflicted) {
			$Min++;
			if($Min > 59) {
				$Conflict = 1;
				DPIntWarn("Unable to resolve \"$summary\" at $Day.$Month.$Year $OrigTime - would require hour switching.");
				$Time = undef;
				last;
			}
			$Conflict = 1;
			$Time = "$Hour:" . AppendZero($Min);
		} else {
			# If it didn't conflict that must mean it worked out.
			last;
		}
	}
	if($Conflict) {
		if(defined($Time)) {
			$ConflictMessage = sprintf($Gettext->get('"%s" at %s has been moved to %s'),$summary,"$Day.$Month.$Year $OrigTime", $Time);
		} else {
			$ConflictMessage = sprintf($Gettext->get('"%s" at %s did not get imported'),$summary,"$Day.$Month.$Year $OrigTime");
		}
	}
	return($ConflictMessage,$Time);
}

# Purpose: Commandline wrapper around the export functions
# Usage: 'x|yzx' => \&CLI_Export,
sub CLI_Export {
	my($Type,$Target) = @_;
	MainInit();
	if($Type =~ /(ical|dpf)/) {
		unless(-w dirname($Target)) {
			die("Unable to write to " . dirname($Target) . "\n");
		}
		if(-d $Target) {
			die("$Target: is a directory\n");
		}
		if($Type =~ /ical/) {
			if(iCal_Exporter($Target)) {
				print "iCalendar data written to $Target\n";
			}
		} elsif($Type =~ /dpf/) {
			if(WriteDayplannerDataFile($Target)) {
				print "Day planner data file ($Target) written\n";
			}
		}
	} elsif($Type =~ /html/) {
		if(-e $Target) {
			unless(-w $Target) {
				die("I don't have write permission to $Target\n");
			}
			unless(-d $Target) {
				die("$Target: is not a directory\n");
			}
		}
		if(HTML_Export($Target)) {
			print "HTML written to $Target\n";
		}
	} else {
		die("Unknown type given as argument to CLI_Export: $Type\n");
	}
	exit(0);
}

# Purpose: Commandline wrapper around the import functions
# Usage: 'x|yzx' => \&CLI_Import,
sub CLI_Import {
	my($Type,$Source) = @_;
	MainInit();
	die("$Source: does not exist\n") unless(-e $Source);
	die("$Source: is not readable by me\n") unless(-r $Source);
	die("$Source: is a directory\n") if (-d $Source);
	# Initialize the daemon (we need it)
	DaemonInit() or die();
	if($Type =~ /ical/) {
		if(iCal_ImportFile($Source)) {
			print "Imported iCalendar data from $Source\n";
		} else {
			print "Importing failed.\n";
		}
	} elsif ($Type =~ /dpf/) {
		if(LoadDayplannerDataFile($Source)) {
			print "Imported day planner data from $Source\n";
		} else {
			print "Importing failed.\n";
		}
	}
	# Save the data
	SaveMainData();
	# Close the daemon connection
	CloseDaemon();
	# Exit peacefully
	exit(0);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# HTML export functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Encode special HTML entities
# Usage: HTML_Encode(STRING);
sub HTML_Encode {
	my $String = shift;
	study($String);
	$String =~ s/&/&amp;/;
	$String =~ s/</&lt;/;
	$String =~ s/>/&gt;/;
	$String =~ s/"/&quot;/;
	return($String);
}

# Purpose: Output the header for all day planner HTML files
# Usage: print $FILE HTML_Header(YEAR,DATE,NONDATEMODE?);
sub HTML_Header {
	my ($Year,$Date,$NonDateMode) = @_;
	my $Header = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
	$Header .= "<html><head>\n";
	$Header .= '<meta content="text/html; charset=iso-8859-1" http-equiv="content-type" />';
	$Header .= "<meta name='generator' content='Day planner $Version - http://home.gna.org/dayplanner' />\n";;
	if($NonDateMode) {
		$Header .= "<title>" . HTML_Encode($Date) . "</title>";
	} else {
		$Header .= "<title>" . HTML_Encode(sprintf($Gettext->get("Day planner for %s"),$Date)) . "</title>";
	}
	$Header .= "</head>\n";
	$Header .= '<body>';
	$Header .= "<h2>" . HTML_Encode($Date) . "</h2>";
	if(defined($NonDateMode) and $NonDateMode eq "M") {
		$Header .= HTML_Encode($Gettext->get("Tools")) . ": <a href='birthdays.html'>" . HTML_Encode($Gettext->get("View a list of birthdays")) . "</a><br />\n";
	} elsif($NonDateMode) {
		$Header .= HTML_Encode($Gettext->get("Tools")) . ": <a href='index.html'>" . HTML_Encode($Gettext->get("View the main page")) . "</a><br/>\n";
	} else {
		$Header .= HTML_Encode($Gettext->get("Tools")) . ": <a href='index.html'>" . HTML_Encode($Gettext->get("Change to another year")) . "</a> (" . HTML_Encode(sprintf($Gettext->get("current: %s"), $Year)) . ") - <a href='birthdays.html'>" . HTML_Encode($Gettext->get("View a list of birthdays")) . "</a><br />\n";
		$Header .= HTML_Encode($Gettext->get("Months")) . ": <a href='january-$Year.html'>" . HTML_Encode($MonthNames{1}) . "</a> - <a href='february-$Year.html'>" . HTML_Encode($MonthNames{2}) . "</a> - <a href='march-$Year.html'>" . HTML_Encode($MonthNames{3}) . "</a> - \n<a href='april-$Year.html'>" . HTML_Encode($MonthNames{4}) . "</a> - <a href='may-$Year.html'>" . HTML_Encode($MonthNames{5}) . "</a> - <a href='june-$Year.html'>" . HTML_Encode($MonthNames{6}) . "</a> - \n<a href='july-$Year.html'>" . HTML_Encode($MonthNames{7}) . "</a> - <a href='august-$Year.html'>" . HTML_Encode($MonthNames{8}) . "</a> - <a href='september-$Year.html'>" . HTML_Encode($MonthNames{9}) . "</a> - \n<a href='october-$Year.html'>" . HTML_Encode($MonthNames{10}) . "</a> - <a href='november-$Year.html'>" . HTML_Encode($MonthNames{11}) . "</a> - <a href='december-$Year.html'>" . HTML_Encode($MonthNames{12}) . "</a><br/>\n";
	}
	$Header .= "<!-- Generated by day planner version $Version - $RCSRev -->\n";
	$Header .= '<hr />';
	return($Header);
}

# Purpose: Print the footer of all day planner HTML documents
# Usage: print $FILE HTML_Footer();
sub HTML_Footer {
	my $Footer = "<br /><small><small>" . HTML_Encode($Gettext->get("Generated by")) .  " <a href='http://home.gna.org/dayplanner'>" . HTML_Encode($Gettext->get("Day Planner")) . "</a> " . HTML_Encode($Gettext->get("version")) . " $Version</small></small><br />";
	$Footer .= "</body></html>";
	return($Footer);
}

# Purpose: Output a specified day to HTML
# Usage: HTML_DayToHtml(YEAR,MONTH,DAY,DIRECTORY);
sub HTML_DayToHtml {
	my ($Year,$Month,$Day,$Directory) = @_;
	open(my $FILE, ">", "$Directory/dp_$Year$Month$Day.html") or do {
		DPIntWarn("Unable to open $Directory/dp_$Year$Month$Day.html for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$Directory/dp_$Year$Month$Day.html", $!));
		return(undef);
	};
	# Header
	print $FILE HTML_Header($Year,"$Day-$Month-$Year");
	print $FILE '<table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">';
	print $FILE "<tbody><tr><td>" . HTML_Encode($Gettext->get("Time")) . "</td><td>" . HTML_Encode($Gettext->get("Description")) . "</td></tr>\n";
	# Write birthdays
	if(BirthdayDayDefined($Month,$Day)) {
		foreach my $Name (sort(keys(%{$BirthdayContents{$Month}{$Day}}))) {
			print $FILE "<tr><td></td><td>" . HTML_Encode(sprintf($Gettext->get("%s's birthday"), $Name)) . "</td></tr>\n";
		}
	}
	# Write standard events
	foreach my $Time (sort(keys(%{$CalendarContents{$Year}{$Month}{$Day}}))) {
		print $FILE "<tr><td>" . HTML_Encode($Time) . "</td><td>" . HTML_Encode($CalendarContents{$Year}{$Month}{$Day}{$Time}{summary});
		if(defined($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext})) {
			my $HTML_Fulltext = HTML_Encode($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext});
			$HTML_Fulltext =~ s#\n#<br />#g;
			print $FILE "<br/><i>$HTML_Fulltext</i>";
		}
		print $FILE "</td></tr>\n";
	}
	# Prepare and write holidays
	unless(defined($HolidayParser)) {
		$HolidayParser = Date::HolidayParser->new($HolidayFile);
	}
	unless(defined($Holidays{$Year})) {
		$Holidays{$Year} = $HolidayParser->get($Year);
	}
	if(defined($Holidays{$Year}) and defined($Holidays{$Year}->{$Month}) and defined($Holidays{$Year}->{$Month}{$Day})) {
		foreach my $CurrHoliday (keys(%{$Holidays{$Year}->{$Month}{$Day}})) {
			print $FILE "<tr><td></td><td> " . HTML_Encode($CurrHoliday) . "</td></tr>\n";
		}
	}
	print $FILE '</tbody></table>';
	print $FILE HTML_Footer();
	close($FILE);
}

# Purpose: Output a specified month in HTML
# Usage: HTML_MonthToHtml
sub HTML_MonthToHtml {
	my ($Year,$Month,$Directory) = @_;
	my %RawMonthNames = (
		1 => "january",
		2 => "february",
		3 => "march",
		4 => "april",
		5 => "may",
		6 => "june",
		7 => "july",
		8 => "august",
		9 => "september",
		10 => "october",
		11 => "november",
		12 => "december"
	);
	open(my $FILE, ">", "$Directory/$RawMonthNames{$Month}-$Year.html") or do {
		DPIntWarn("Unable to open $Directory/$RawMonthNames{$Month}-$Year.html for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$RawMonthNames{$Month}-$Year.html", $!));
		return(undef);
	};
	print $FILE HTML_Header($Year, "$MonthNames{$Month} $Year");
	my $HadContent;
	if(defined($CalendarContents{$Year}{$Month})) {
		foreach my $Day (sort {$a <=> $b } keys(%{$CalendarContents{$Year}{$Month}})) {
			$HadContent = 1;
			print $FILE "<a href='dp_$Year$Month$Day.html'>" . HTML_Encode("$Day. $MonthNames{$Month} $Year") . "</a><br/>\n";
		}
	}
	unless($HadContent) {
		print $FILE "<i>" . HTML_Encode($Gettext->get("There are no events this month")) . "</i>";
	}
	if(keys(%BirthdayContents) and keys(%{$BirthdayContents{$Month}})) {
		print $FILE '<br /><h3>' . HTML_Encode($Gettext->get("Birthdays this month:")) . "</h3>";
		print $FILE '<table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">' . "\n";
		print $FILE "<tbody><tr><td>" . HTML_Encode($Gettext->get("Date")) . "</td><td>" . HTML_Encode($Gettext->get("Name")) . "</td></tr>\n";
		foreach my $Day (sort {$a <=> $b} keys(%{$BirthdayContents{$Month}})) {
			foreach my $Name (sort(keys(%{$BirthdayContents{$Month}{$Day}}))) {
				print $FILE "<tr><td>" . HTML_Encode("$Day. $MonthNames{$Month}") . "</td><td>" . HTML_Encode($Name) . "</td></tr>\n";
			}
		}
		print $FILE '</tbody></table>';
	}
	# Prepare and write holidays
	unless(defined($HolidayParser)) {
		$HolidayParser = Date::HolidayParser->new($HolidayFile);
	}
	unless(defined($Holidays{$Year})) {
		$Holidays{$Year} = $HolidayParser->get($Year);
	}
	if(defined($Holidays{$Year}) and defined($Holidays{$Year}->{$Month})) {
		print $FILE "<h4>" . HTML_Encode($Gettext->get("Special days this month:")) . "</h4>";
		foreach my $Day (sort {$a <=> $b} keys %{$Holidays{$Year}->{$Month}}) {
			foreach my $CurrHoliday (keys(%{$Holidays{$Year}->{$Month}{$Day}})) {
				print $FILE HTML_Encode("$Day. $MonthNames{$Month}: $CurrHoliday") . "<br/>\n"
			}
		}
	}
	print $FILE HTML_Footer();
	close($FILE);
}

# Purpose: Output all birthdays to a file
# Usage: HTML_BirthdayList(DIRECTORY);
sub HTML_BirthdayList {
	my($Directory) = @_;
	open(my $FILE, ">", "$Directory/birthdays.html") or do {
		DPIntWarn("Unable to open $Directory/birthdays.html for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$Directory/birthdays.html", $!));
		return(undef);
	};
	print $FILE HTML_Header(undef,$Gettext->get("Birthdays"),1);
	if(keys(%BirthdayContents)) {
		print $FILE '<table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">';
		print $FILE "<tbody><tr><td>" . HTML_Encode($Gettext->get("Date")) . "</td><td>" . HTML_Encode($Gettext->get("Name")) . "</td></tr>\n";
		foreach my $Month (sort {$a <=> $b}  keys(%BirthdayContents)) {
			foreach my $Day (sort {$a <=> $b} keys(%{$BirthdayContents{$Month}})) {
				foreach my $Name (sort(keys(%{$BirthdayContents{$Month}{$Day}}))) {
					print $FILE "<tr><td>" . HTML_Encode("$Day $MonthNames{$Month}") . "</td><td>" . HTML_Encode($Name) . "</td></tr>\n";
				}
			}
		}
		print $FILE '</tbody></table>';
	} else {
		print $FILE . "<i>" .  HTML_Encode($Gettext->get("No birthdays are defined.")) . "</i><br/>";
	}
	print $FILE HTML_Footer();
}

# Purpose: Output a year information page to HTML
# Usage: HTML_YearHtml(YEAR,DIRECTORY);
sub HTML_YearHtml {
	my ($Year, $Directory) = @_;
	open(my $FILE, ">", "$Directory/$Year.html") or do {
		DPIntWarn("Unable to open $Directory/$Year.html for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$Directory/$Year.html", $!));
		return(undef);
	};
	print $FILE HTML_Header($Year, $Year, 0);
	print $FILE HTML_Encode($Gettext->get("Select the month to view in the list above")) . "<br />\n";
	print $FILE HTML_Footer();
}

# Purpose: Output a list of years (aka. the index page) to HTML
# Usage: HTML_YearList(DIRECTORY);
sub HTML_YearList {
	my ($Directory) = @_;
	open(my $FILE, ">", "$Directory/index.html") or do {
		DPIntWarn("Unable to open $Directory/index.html for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$Directory/index.html", $!));
		return(undef);
	};
	print $FILE HTML_Header("", "Day planner", "M");
	print $FILE HTML_Encode($Gettext->get("Select the year to view:")) . "<br />\n";
	foreach(sort { $b <=> $a } keys(%CalendarContents)) {
		print $FILE "<a href='$_.html'>" . HTML_Encode($_) . "</a><br />\n";
	}
	print $FILE HTML_Footer();
}

# Purpose: Output a php file that adds autodetection of todays date to
# 	day planner HTML exports
# Usage: HTML_PHPIndex(DIRECTORY);
sub HTML_PHPIndex {
	my ($Directory) = @_;
	open(my $FILE, ">", "$Directory/index.php") or do {
		DPIntWarn("Unable to open $Directory/index.php for writing: $!");
		DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), "$Directory/index.php", $!));
		return(undef);
	};
	print $FILE "<?php\n// This is a simple script written by day planner to add autodetection of\n// the current day to exported day planner HTML sites. Only useful on\n// webservers with php support.\n// Copyright (C) Eskild Hustvedt 2006. Licensed under the same license as day planer\n";
	print $FILE '$Year = date("Y");' . "\n";
	print $FILE '$Month = date("n");' . "\n";
	print $FILE '$Day = date("j");' . "\n";
	print $FILE '$Months = array(1 => "january", 2 => "february", 3 => "march", 4 => "april", 5 => "may", 6 => "june", 7 => "july", 8 =>"august", 9 =>"september", 10 => "october", 11 => "november", 12 =>"december");' . "\n";
	print $FILE 'if(file_exists("./dp_$Year$Month$Day.html")) {' . "\n";
	print $FILE "\t" . 'include("./dp_$Year$Month$Day.html");' . "\n";
	print $FILE '} elseif(file_exists("./$Months[$Month]-$Year.html")) {' . "\n";
	print $FILE "\t" . 'include("./$Months[$Month]-$Year.html");' . "\n";
	print $FILE '} elseif(file_exists("./index.html")) {' . "\n";
	print $FILE "\t" . 'include("./index.html");' . "\n";
	print $FILE "} else {" . "\n";
	print $FILE "\t" . 'print("Neither \"./dp_$Year$Month$Day.html\", \"./$Months[$Month]-$Year.html\" nor \"./index.html\" existed!\nThis export is corrupt.");' . "\n";
	print $FILE "}\n?>";
}

# Purpose: Export day planner data to HTML
# Usage: HTML_Export(DIRECTORY);
sub HTML_Export {
	my %RawMonthNames = (
		1 => "january",
		2 => "february",
		3 => "march",
		4 => "april",
		5 => "may",
		6 => "june",
		7 => "july",
		8 => "august",
		9 => "september",
		10 => "october",
		11 => "november",
		12 => "december"
	);
	my $Dir = $_[0];
	unless(-d $Dir) {
		eval("mkpath('$Dir')");
		if($@) {
			DPIntWarn("Unable to mkpath($Dir): $@");
			DPError(sprintf($Gettext->get("Unable to create the directory %s: %s", $Dir, $@)));
			return(undef);
		}
	}
	foreach my $Year (keys(%CalendarContents)) {
		HTML_YearHtml($Year,$Dir);
		foreach my $Month (keys(%{$CalendarContents{$Year}})) {
			foreach my $Day (keys(%{$CalendarContents{$Year}{$Month}})) {
				HTML_DayToHtml($Year, $Month, $Day, $Dir);
			}
		}
		foreach(1..12) {
			HTML_MonthToHtml($Year,$_,$Dir);
		}
	}
	HTML_YearList($Dir);
	HTML_PHPIndex($Dir);
	HTML_BirthdayList($Dir);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Plan migration functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Purge the current $PlanConvertHash-> buffer and put it into %CalendarContents
# Usage: PlanConvert_PurgeBuffer(\%PlanConvertHash);
sub PlanConvert_PurgeBuffer {
	my $PlanConvertHash = $_[0];
	my $ErrorMessage;
	if(defined($PlanConvertHash->{Day})) {
		if ($PlanConvertHash->{Type} eq 'normal') {
			# Check for conflicts
			if (defined($CalendarContents{$PlanConvertHash->{Year}}{$PlanConvertHash->{Month}}{$PlanConvertHash->{Day}}{$PlanConvertHash->{Time}})) {
				# Try to fix it
				($ErrorMessage, $PlanConvertHash->{Time}) = Import_ResolveConflict($PlanConvertHash->{Year},$PlanConvertHash->{Month},$PlanConvertHash->{Day},$PlanConvertHash->{Time}, $PlanConvertHash->{Summary}, $PlanConvertHash->{Fulltext});
			}
			if (defined($PlanConvertHash->{Summary})) {
				$CalendarContents{$PlanConvertHash->{Year}}{$PlanConvertHash->{Month}}{$PlanConvertHash->{Day}}{$PlanConvertHash->{Time}}{summary} = $PlanConvertHash->{Summary};
				delete($PlanConvertHash->{Summary});
			}
			if (defined($PlanConvertHash->{Fulltext})) {
				$CalendarContents{$PlanConvertHash->{Year}}{$PlanConvertHash->{Month}}{$PlanConvertHash->{Day}}{$PlanConvertHash->{Time}}{fulltext} = $PlanConvertHash->{Fulltext};
				delete($PlanConvertHash->{Fulltext});
			}
			delete($PlanConvertHash->{Day});
			delete($PlanConvertHash->{Month});
			delete($PlanConvertHash->{Year});
			delete($PlanConvertHash->{Time});
		} elsif ($PlanConvertHash->{Type} eq 'bday') {
			if (defined($PlanConvertHash->{Summary})) {
				$BirthdayContents{$PlanConvertHash->{Month}}{$PlanConvertHash->{Day}}{$PlanConvertHash->{Summary}} = 1;
				delete($PlanConvertHash->{Summary});
			}
			delete($PlanConvertHash->{Day});
			delete($PlanConvertHash->{Month});
			delete($PlanConvertHash->{Year});
			delete($PlanConvertHash->{Time});
			delete($PlanConvertHash->{Fulltext});
		} else {
			DPIntWarn("BUG!!! Invalid type: $PlanConvertHash->{Type}. This could result in dangerous errors.");
		}
		$PlanConvertHash->{Type} = 'normal';
	}
}

# Purpose: Convert the file supplied
# Usage: PlanConvert_PurgeBuffer(/path/to/file,\%PlanConvertHash, $ProgressBar);
sub PlanConvert_ProcessFile {
	my $PlanConvertHash = $_[1]; 
	my $ProgressBar = $_[2];
	$PlanConvertHash->{Type} = 'normal';

	open(PLAN_FILE,$_[0]) or do {
		DPIntWarn("Unable to open $_[0]: $!");
		return(0);
	};
	my $LineNo = 0;
	while(<PLAN_FILE>) {
		$LineNo++;
		next if /^\s*(O|o|t|e|l|a|y|P|p|m|L|u|E)/;	# These are Plan specific stuff, just ignore them
		chomp;
		if (/^\s*(N)/) {		# Entry equalent to the dayplanner summary
			my $Summary = $_;
			$Summary =~ s#^\s*N\s+(.*)#$1#;
			$PlanConvertHash->{Summary} = $Summary;
		} elsif (/^\s*(M)/) {		# Entry equalent to the dayplanner fulltext
			my $Fulltext = $_;
			$Fulltext =~ s#^\s*M\s+(.*)#$1#;
			if(defined($PlanConvertHash->{Fulltext})) {
				$PlanConvertHash->{Fulltext} = "$PlanConvertHash->{Fulltext} $Fulltext";
			} else {
				$PlanConvertHash->{Fulltext} = $Fulltext;
			}
		} elsif (/^\s*(R)/) {		# These we just skip but might parse at some point
			if (/^\s*R\s+0\s+0\s+0\s+0\s+1/) {
				$PlanConvertHash->{Type} = 'bday';
			} else {
				next;
			}
		} elsif (/^\s*\d/) {		# Okay, it starts with a digit, it's a new date
			PlanConvert_PurgeBuffer($PlanConvertHash);
			my ($Day,$Month,$Year,$Time) = ($_,$_,$_,$_);
			# Get the day
			$Day =~ s#^\s*\d+/(\d+)/.*#$1#;
			# Get the month
			$Month =~ s#^\s*(\d+)/\d+/.*#$1#;
			# Get the year
			$Year =~ s#^\s*\d+/\d+/(\d+)\s+.*#$1#;
			# Get the time
			$Time =~ s#\s*\d+/\d+/\d+\s+(\d+:\d+):\d+\s+.*#$1#;
			# Convert the time to a more dayplannerish format
			$Time = "00:00" if $Time eq '99:99';
			if ($Time =~ /^\d+:\d$/) {
				$Time = $Time . 0;
			}
			if ($Time =~ /^\d:\d*$/) {
				$Time = 0 . $Time;
			}
			# Set the variables in the hash
			$PlanConvertHash->{Day} = $Day;
			$PlanConvertHash->{Month} = $Month;
			$PlanConvertHash->{Year} = $Year;
			$PlanConvertHash->{Time} = $Time;
		} else {
			DPIntWarn("WARNING: Unrecognized line (please report this): $_[0]:$LineNo: $_");
			next;
		}
		PulsateProgressbar($ProgressBar);
	}
	return(1);
}

# Purpose: Start converting plan
# Usage: MigratePlan(IS_FIRST_TEST?);
sub MigratePlan {
	my $IsFirstTest = $_[0];
	my @MigrateFiles;
	
	
	foreach my $Dir ("$ENV{HOME}/.plan","$ENV{HOME}/.plan.dir") {
		if (defined($Dir) and -d $Dir and -e "$Dir/dayplan") {
			foreach my $File (<$Dir/*>) {
				next if $File =~ /(lock\.pland|pland|holiday)$/;
				push(@MigrateFiles, $File);
			}
		}
	}

	# Perform some specific magic on first run
	if($IsFirstTest) {
		if(@MigrateFiles) {
			unless(DPQuestion($Gettext->get("Welcome to day planner.\n\nDay Planner has detected existing calendar data from \"plan\". Do you want Day Planner to import this data? The plan data will still be left intact."))) {
				return(1);
			}
		} else {
			return(1);
		}
	}

	if(@MigrateFiles) {
		my $ProgressWin = Gtk2::Window->new();
		$ProgressWin->set_modal(1);
		$ProgressWin->set_border_width(5);
		$ProgressWin->set_skip_taskbar_hint(1);
		$ProgressWin->set_skip_pager_hint(1);
		if(defined($MainWindow)) {
			$ProgressWin->set_transient_for($MainWindow);
			$ProgressWin->set_position('center-on-parent');
		} else {
			$ProgressWin->set_position("center");
		}
		$ProgressWin->set_title($Gettext->get("Migrating..."));
		$ProgressWin->set_resizable(0);
	
		# Create the HBox and label
		my $ProgVBox = Gtk2::VBox->new();
		my $ProgLabel = Gtk2::Label->new($Gettext->get("Migrating plan to day planner..."));
		$ProgVBox->pack_start($ProgLabel,0,0,0);
		$ProgressWin->add($ProgVBox);
	
		# Create the progress bar
		my $ProgressBar = Gtk2::ProgressBar->new();
		$ProgressBar->{activity_mode} = 0;
		$ProgressBar->set_fraction(0.0);
		$ProgVBox->pack_end($ProgressBar,0,0,0);
		
		# Show it
		$ProgVBox->show();
		$ProgLabel->show();
		$ProgressBar->show();
		$ProgressWin->show();
		Gtk2->main_iteration while Gtk2->events_pending;

		# Loop through the data and convert it
		foreach my $File (@MigrateFiles) {
			my %PlanConvertHash;
			if(PlanConvert_ProcessFile($File,\%PlanConvertHash, $ProgressBar)) {
				PlanConvert_PurgeBuffer(\%PlanConvertHash);
			}
			PulsateProgressbar($ProgressBar);
		} 
		$ProgressWin->destroy();
		DPInfo($Gettext->get("The plan data has been successfully migrated to Day Planner.\n\nPlease note that not all of plans advanced features are supported in day planner so some settings (namely repeating appointments and scripts) may not have been completely migrated."));
	} else {
		DPError($Gettext->get("Day planner was unable to detect any plan data-files.")) unless $IsFirstTest;
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Encryption/decryption functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Encrypt the supplied data
# Usage: my $EncryptedData = EncryptData(DATA);
sub EncryptData {
	my $Data = $_[0];
	unless(eval('use Crypt::CBC;1;')) {
		DPError(sprintf($Gettext->get("The perl module %s is not installed. The data will not be encrypted."),"Crypt::CBC"));
		return($Data);
	}
	unless(eval('use Crypt::Blowfish; 1')) {
		DPError(sprintf($Gettext->get("The perl module %s is not installed. The data will not be encrypted."),"Crypt::Blowfish"));
		return($Data);
	}
	my $Key = GetEncryptionKey();
	my $Encrypt = Crypt::CBC->new({
			key => $Key,
			cipher => "Blowfish",
			salt => 1,
		});
	return($Encrypt->encrypt($Data));
}

# Purpose: Graphically prompt the user for the encryption key
# Usage: my $Key = GetEncryptionKey();
sub GetEncryptionKey {
	my $Password;

	# Create the indow
	my $PasswdDialog = Gtk2::Dialog->new($Gettext->get("Password"), $MainWindow, 'modal',
	'gtk-ok' => 'ok');
	$PasswdDialog->set_resizable(0);
	$PasswdDialog->set_border_width(5);
	$PasswdDialog->set_default_response ('ok');
	
	# Create the top lbel
	my $Label = Gtk2::Label->new($Gettext->get('Please enter a password.'));
	$Label->show();
	$PasswdDialog->vbox->pack_start($Label,0,0,0);

	# Create the first input boxes
	my $FirstInputHBox = Gtk2::HBox->new();
	my $FirstInputLabel = Gtk2::Label->new($Gettext->get('Password') . ":");
	my $FirstInputEntry = Gtk2::Entry->new();
	$FirstInputHBox->pack_start($FirstInputLabel,0,0,0);
	$FirstInputEntry->set_editable(1);
	$FirstInputEntry->set_visibility(0);
	$FirstInputEntry->set_activates_default(1);
	$FirstInputHBox->pack_end($FirstInputEntry,0,0,0);
	$FirstInputHBox->show();
	$FirstInputEntry->show();
	$FirstInputLabel->show();

	# Create the second input boxes
	my $SecondInputHBox = Gtk2::HBox->new();
	my $SecondInputLabel = Gtk2::Label->new($Gettext->get('Repeat the password:'));
	my $SecondInputEntry = Gtk2::Entry->new();
	$SecondInputEntry->set_editable(1);
	$SecondInputEntry->set_visibility(0);
	$SecondInputEntry->set_activates_default(1);
	$SecondInputEntry->show();
	$SecondInputHBox->pack_end($SecondInputEntry,0,0,0);
	$SecondInputHBox->pack_start($SecondInputLabel,0,0,0);
	$SecondInputHBox->show();
	$SecondInputLabel->show();

	# Pack The HBoxes onto the window widget
	$PasswdDialog->vbox->pack_start($FirstInputHBox,0,0,0);
	$PasswdDialog->vbox->pack_start($SecondInputHBox,0,0,0);

	# Run it
	while(1) {
		my $Response = $PasswdDialog->run();
		my $FirstPWD = $FirstInputEntry->get_text();
		my $SecondPWD = $SecondInputEntry->get_text();
		if($FirstPWD eq $SecondPWD) {
			if(length($FirstPWD) < 6) {
				$Label->set_label($Gettext->get("The password must be at least 6 characters long.") . "\n" . $Gettext->get('Please enter a password.'));
			} else {
				$Password = $FirstPWD;
				last;
			}
		} else {
			$Label->set_label($Gettext->get("The passwords do not match.") . "\n" . $Gettext->get('Please enter a password.'));
		}
	}
	$PasswdDialog->destroy();
	return($Password);
}

# Purpose: Graphically prompt the user for the encryption key and decrypt the
# 		supplied data
# Usage: my $Response = DecryptData(DATA,MD5);
#	Returns undef on "cancel".
sub DecryptData {
	my ($Data,$MD5) = @_;
	unless($Gtk2Init) {
		die("Can't decrypt encrypted data without the GUI\n");
	}
	# Verify deps
	unless(eval('use Crypt::CBC;1;')) {
		DPError(sprintf($Gettext->get("The perl module %s is not installed. The data will not be encrypted."),"Crypt::CBC"));
		return(undef);
	}
	unless(eval('use Crypt::Blowfish; 1')) {
		DPError(sprintf($Gettext->get("The perl module %s is not installed. The data will not be encrypted."),"Crypt::Blowfish"));
		return($_[0]);
	}
	# Create the indow
	my $PasswdDialog = Gtk2::Dialog->new($Gettext->get("Password"), $MainWindow, 'modal',
		'gtk-cancel' => 'cancel',
		'gtk-ok' => 'ok');
	$PasswdDialog->set_resizable(0);
	$PasswdDialog->set_border_width(5);
	$PasswdDialog->set_default_response ('ok');
	
	# Create the top lbel
	my $Label = Gtk2::Label->new($Gettext->get('This file is password protected.'));
	$Label->show();
	$Label->set_justify('left');
	$PasswdDialog->vbox->pack_start($Label,1,1,0);

	# Create the first input boxes
	my $InputHBox = Gtk2::HBox->new();
	my $InputLabel = Gtk2::Label->new($Gettext->get('Password') . ":");
	my $InputEntry = Gtk2::Entry->new();
	$InputHBox->pack_start($InputLabel,0,0,0);
	$InputEntry->set_editable(1);
	$InputEntry->set_visibility(0);
	$InputEntry->set_activates_default(1);
	$InputHBox->pack_end($InputEntry,0,0,0);
	$InputHBox->show();
	$InputEntry->show();
	$InputLabel->show();
	$PasswdDialog->vbox->pack_start($InputHBox,0,0,0);
	while (1) {
		my $Reply = $PasswdDialog->run();
		unless($Reply eq 'ok') {
			$PasswdDialog->destroy();
			return(undef);
		}
		my $Key = $InputEntry->get_text;
		# Decryption function
		my $Encrypt = Crypt::CBC->new({
				key => $Key,
				cipher => "Blowfish",
				salt => 1,
			});
		my $Decrypted = $Encrypt->decrypt($Data);
		my $DecryptedMD5 = md5_base64($Decrypted);
		if($DecryptedMD5 eq $MD5) {
			$PasswdDialog->destroy();
			return($Decrypted);
		}
		$Label->set_text($Gettext->get("Invalid password.") . "\n" . $Gettext->get('This file is password protected.'));
		$InputEntry->set_text('');
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# iCalendar functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Escape certain characters that are special in iCalendar
# Usage: my $SafeData = iCal_GetSafe($Data);
sub iCal_GetSafe {
	my $Data = $_[0];
	$Data =~ s/\\/\\\\/g;
	$Data =~ s/,/\,/g;
	$Data =~ s/;/\;/g;
	$Data =~ s/\n/\\n/g;
	return($Data);
}

# Purpose: Get a unique ID for an event
# Usage: print $TARGET iCal_UID($Year?$Month$Day$Hour?$Minute, $Summary);
sub iCal_UID {
	chomp(@_);
	return("UID:dayplanner-" . time() . encode_base64($_[0],"") . encode_base64($_[1],"") . "\r\n");
}

# Purpose: Export the day planner data to a file in the iCalendar format
# Usage: iCal_Exporter(FILE, OnlyBirthdays?);
sub iCal_Exporter {
	my $File = $_[0];
	my $BirthdaysOnly = $_[1];
	open(my $TARGET, ">", $File) or do {
		DPIntWarn("Unable to open $File for writing: $!");
		DPWarning(sprintf($Gettext->get("Unable to open %s for writing: %s"), $File, $!));
		return(0);
	};
	# Print initial info. The prodid could probably be changed to something mroe suitable.
	print $TARGET "BEGIN:VCALENDAR\r\nVERSION:2.0\r\nPRODID:-//EskildHustvedt//NONSGML Day Planner $Version//EN\r\nCALSCALE:GREGORIAN\r\n";

	# Begin exporting birthdays
	foreach my $Month (keys(%BirthdayContents)) {
		foreach my $Day (keys(%{$BirthdayContents{$Month}})) {
				foreach my $Name (keys(%{$BirthdayContents{$Month}{$Day}})) {
					$Month = AppendZero($Month);
					$Day = AppendZero($Day);
					print $TARGET "BEGIN:VEVENT\r\n";
					# The unix epoch starts in 1970 so we put that in here as the start time
					# for the event (we have no idea when a person was born)
					print $TARGET "DTSTART:1970$Month${Day}T000000\r\n";
					print $TARGET "DTEND:1970$Month${Day}T235959\r\n";
					# Day planner-style recurrance
					print $TARGET "RRULE:FREQ=YEARLY\r\n";
					# The summary is the name +'s birthday (localized).
					print $TARGET "SUMMARY:" . iCal_GetSafe(sprintf($Gettext->get("%s's birthday"), $Name)) . "\r\n";
					# X-DP-BIRTHDAY = TRUE will make day planner know more easily it's a birthday.
					print $TARGET "X-DP-BIRTHDAY:TRUE\r\n";
					# If X-DP-BIRTHDAY is TRUE then day planner will ignore SUMMARY: and use
					# X-DP-BIRTHDAYNAME instead.
					print $TARGET "X-DP-BIRTHDAYNAME:" . iCal_GetSafe($Name) . "\r\n";

					# Most (maybe all) other calendars will happily ignore X-DP-BIRTHDAY*. It will be
					# useful for day planner importing though.

					# Get a unique identifier
					print $TARGET iCal_UID("$Month$Day", $Name);
					print $TARGET "END:VEVENT\r\n";
				}
			}
		}
	# Export the rest of the data if needed
	unless($BirthdaysOnly) {
		foreach my $Year (keys(%CalendarContents)) {
			foreach my $Month (keys(%{$CalendarContents{$Year}})) {
				foreach my $Day (keys(%{$CalendarContents{$Year}{$Month}})) {
					foreach my $Time(keys(%{$CalendarContents{$Year}{$Month}{$Day}})) {
						# Fix the month and day
						my $iCalMonth = AppendZero($Month);
						my $iCalDay = AppendZero($Day);

						# Get the time
						my $Hour = $Time;
						my $Minute = $Time;
						$Hour =~ s/^(\d+):\d+$/$1/;
						$Minute =~ s/^\d+:(\d+)$/$1/;
						
						print $TARGET "BEGIN:VEVENT\r\n";
						print $TARGET "DTSTART:$Year$iCalMonth${iCalDay}T$Hour${Minute}00\r\n";
						print $TARGET "DTEND:$Year$iCalMonth${iCalDay}T$Hour${Minute}59\r\n";
						print $TARGET "SUMMARY:" . iCal_GetSafe($CalendarContents{$Year}{$Month}{$Day}{$Time}{summary}) . "\r\n";
						if(defined($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext}) and length($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext})) {
							print $TARGET "DESCRIPTION:" . iCal_GetSafe($CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext}) . "\r\n";
						}
						print $TARGET iCal_UID("$Year$Month$Day$Time", $CalendarContents{$Year}{$Month}{$Day}{$Time}{summary});
						print $TARGET "END:VEVENT\r\n";

					}
				}
			}
		}
	}
	print $TARGET "END:VCALENDAR\r\n";
	close($TARGET);
}

# Purpose: Loads an iCalendar file and returns a simple data structure. Returns
# 	undef on failure.
# Usage: my $iCalendar = iCal_LoadFile(FILE);
sub iCal_LoadFile {
	my $File = $_[0];
	my @iCalendarStructures;
	my $LastStructure;
	my $LastName = undef;
	my $CurrentStructure;
	open(my $ICALENDAR, "<", $File);

	while(<$ICALENDAR>) {
		s/\r//;
		chomp;
		if (s/^\s//) {
			$iCalendarStructures[$CurrentStructure]{$LastName} .= $_;
		} elsif(/^END/) {
			next;
		} else {
			my $Name = $_;
			my $Value = $_;
			$Name =~ s/(.+):(.*)$/$1/;
			$Value =~ s/(.+):(.*)$/$2/;
			if($Name =~ /^BEGIN/) {
				$CurrentStructure++;
				$Name = "X-PARSER_ENTRYTYPE";
			}
			$LastName = $Name;
			$iCalendarStructures[$CurrentStructure]{$Name} = iCal_UnSafe($Value);
		}
	}
	close($ICALENDAR);
	return(\@iCalendarStructures);
}

# Purpose: Removes escaping of iCalendar entries
# Usage: my $UnsafeEntry = iCal_UnSafe($DATA);
sub iCal_UnSafe {
	my $Data = $_[0];
	$Data =~ s/\\\\/\\/g;
	$Data =~ s/\\,/,/g;
	$Data =~ s/\\;/;/g;
	$Data =~ s/\\n/\n/g;
	return($Data);
}

# Purpose: Imports files in the iCalendar format into day planner
# Usage: iCal_ImportFile(FILE);
sub iCal_ImportFile {
	my $Data = iCal_LoadFile($_[0]);
	return(undef) unless(defined($Data));
	foreach(0..scalar(@{$Data})) {
		my $Current = $Data->[$_];
		my ($Summary, $Fulltext);
		# First make sure we've got everything we need. Skip entries
		# missing some things.
		next unless(defined($Current->{"X-PARSER_ENTRYTYPE"}));
		next unless($Current->{"X-PARSER_ENTRYTYPE"} eq 'VEVENT');
		unless(defined($Current->{'DTSTART'})) {
			# Detect an alternate dstart
			foreach(keys(%{$Current})) {
				if(/^DTSTART/) {
					$Current->{'DTSTART'} = $Current->{$_};
					last;
				}
			}
			next unless(defined($Current->{'DTSTART'}));
		}
		# FIXME: Don't blindly assume $Time is set.
		my ($Year, $Month, $Day, $Time) = iCal_ParseDateTime($Current->{'DTSTART'});
		$Year =~ s/^0*//;
		$Month =~ s/^0*//;
		$Day =~ s/^0*//;
		next unless(defined($Year));
		if($Current->{RRULE}) {
			if($Current->{RRULE} =~ /YEARLY/) {
				# Birthday?
				if($Current->{"X-DP-BIRTHDAY"} eq "TRUE") {
					if(defined($Current->{"X-DP-BIRTHDAYNAME"})) {
						$Summary = iCal_UnSafe($Current->{"X-DP-BIRTHDAYNAME"});
					} else {
						$Summary = iCal_UnSafe($Current->{"SUMMARY"});
					}
				} else {
					if(defined($Current->{"SUMMARY"})) {
						$Summary = iCal_UnSafe($Current->{"SUMMARY"});
					} else {
						next;
					}
				}
				$BirthdayContents{$Month}{$Day}{$Summary} = 1;
				next unless defined($Current->{DESCRIPTION});
			} else {
				next unless defined($Current->{DESCRIPTION});
			}
		}
		if(defined($Current->{DESCRIPTION})) {
			$Fulltext = iCal_UnSafe($Current->{DESCRIPTION});
		}
		unless(defined($Summary)) {
			if(defined($Current->{SUMMARY})) {
				$Summary = iCal_UnSafe($Current->{SUMMARY});
			} else {
				$Summary = $Gettext->get("Unknown");
			}
		}
		my $ConflictText;
		($ConflictText,$Time) = Import_ResolveConflict($Year,$Month,$Day,$Time,$Summary,$Fulltext);
		if($Time) {
			$CalendarContents{$Year}{$Month}{$Day}{$Time}{summary} = $Summary;
			$CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext} = $Fulltext;
		}
	}
	return(1);
}

# Purpose: Parse an iCalendar date-time
# Usage: my ($Year, $Month, $Day, $Time) = iCal_ParseDateTime(DATE-TIME_ENTRY);
# TODO: Handle VALUE=DATE:YYYYMMDD once full day events are available
# FIXME: YYYYMMDD is actually valid. So we'll need to check for that.
sub iCal_ParseDateTime {
	my $Year = $_[0];
	my $Month = $_[0];
	my $Day = $_[0];
	my $Hour = $_[0];
	my $Minutes = $_[0];

	$Year =~ s/^(\d\d\d\d).*$/$1/;
	$Month =~ s/^\d\d\d\d(\d\d).*$/$1/;
	$Day =~ s/^\d\d\d\d\d\d(\d\d).*$/$1/;

	$Hour =~ s/^.+T//;
	$Hour =~ s/^(\d\d).*$/$1/;
	$Minutes =~ s/^.+T//;
	$Minutes =~ s/^\d\d(\d\d)\d*$/$1/;
	return($Year,$Month,$Day,AppendZero($Hour) . ":" . AppendZero($Minutes));
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Day planner data format functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Write the day planner data format
# Usage: WriteDayplannerDataFile(FILE, ONLY_BIRTHDAYS?, ENCRYPT?);
sub WriteDayplannerDataFile {
	# NOTE: This function MUST be able to work without the GUI initialized (exluding the encryption part)
	my $FormatVersion = 1;
	my $OnlyBirthdays = $_[1] ? 1 : 0;
	my $DPEncrypt = $_[2] ? 1 : 0;
	my $File = $_[0];
	open(my $Target, ">", $File) or do {
		DPIntWarn("Unable to open $File for writing: $!");
		DPWarning(sprintf($Gettext->get("Unable to open %s for writing: %s"), $File, $!));
		return(0);
	};
	
	my($Data, $DataMD5) = DPF_GetData($OnlyBirthdays, $DPEncrypt);

	print $Target "# Content-type: text/x-dayplanner\n# Day planner data file.\n";
	print $Target "DP_FormatVersion = $FormatVersion;\nDP_Crypt = $DPEncrypt;\n";
	print $Target "DP_DataMD5 = $DataMD5\n";
	print $Target "ContainedData = $Data";
	print $Target "# END";
	close($Target);
}

# Purpose: Get day planner data encoded in base64
# Usage: my ($Data, $MD5Sum) = DPF_GetData(ONLY_BIRTHDAYS?, ENCRYPT?, INCLUDE_NEWLINES_IN_BASE64?, SORT_KEYS?, EXCLUDE_METADATA?);
sub DPF_GetData {
	my ($OnlyBirthdays, $DPEncrypt, $Base64_NoEOL, $SortKeys, $ExcludeMeta) = @_;
	$OnlyBirthdays = $OnlyBirthdays ? 1 : 0;
	$SortKeys = $SortKeys ? 1 : 0;
	$ExcludeMeta = $ExcludeMeta ? 1 : 0;
	$Base64_NoEOL = $Base64_NoEOL ? "" : "\n";
	# We want the dumper to be pure (aka. make dumper output a proper syntax that is suitable for eval() or do())
	$Data::Dumper::Purity = 1;
	# Set sort setting
	$Data::Dumper::Sortkeys = $SortKeys;
	# Set the indentation (none in this case)
	$Data::Dumper::Indent = 0;
	my $Data = "\$DP_OnlyBirthdays = '$OnlyBirthdays';\n";;
       	if (not $ExcludeMeta) {
		$Data .= "\$DP_Exportedby = '$Version';\n\$DP_ExportedAt = '" . time() . "';\n";
	}
	$Data .= Data::Dumper->Dump([\%BirthdayContents], ["*BirthdayCalendarContent"]);

	if(not $OnlyBirthdays) {
		$Data .= "\n";
		$Data .= Data::Dumper->Dump([\%CalendarContents], ["*MainCalendarContent"]);
	}
	my $DataMD5 = md5_base64($Data);
	if($DPEncrypt) {
		$Data = EncryptData($Data);
	}
	return(encode_base64($Data, $Base64_NoEOL), $DataMD5);
}

# Purpose: Parse day planner data encoded in base64
# Usage: my($PossibleCorruption, @Conflicts) = DPF_ParseData(BASE64_ENCODED_DATA, DATAMD5, CRYPT);
sub DPF_ParseData {
	my ($ContainedData, $DP_DataMD5, $DP_Crypt) = @_;
	my (@Conflicts, $PossibleCorruption);
	$ContainedData = decode_base64($ContainedData);
	if($DP_Crypt) {
		$ContainedData = DecryptData($ContainedData, $DP_DataMD5);
		# If the returned data is undef then the user pressed cancel.
		unless(defined($ContainedData)) {
			return(undef);
		}
	} else {
		# Verify the md5 sum (the decryption function does that for us, so it's not needed
		#  for encrypted files).
		my $ContainedMD5 = md5_base64($ContainedData);
		unless($ContainedMD5 eq $DP_DataMD5) {
			DPIntWarn("Checksumming failed! The input data is almost certainly corrupt!");
			$PossibleCorruption = 1;
		}
	}
	$ContainedData .= "1;";
	my ($DP_OnlyBirthdays, $DP_Exportedby, $DP_ExportedAt, %BirthdayCalendarContent, %MainCalendarContent);
	eval($ContainedData) or do {
		DPIntWarn("FAILED to parse data!");
		return(undef);
	};
	# First insert the birthdays. We do this mindlessly as there won't be any
	# conflicts anyway
	foreach my $Month (keys(%BirthdayCalendarContent)) {
		foreach my $Day (keys(%{$BirthdayCalendarContent{$Month}})) {
				foreach my $Name (keys(%{$BirthdayCalendarContent{$Month}{$Day}})) {
					$BirthdayContents{$Month}{$Day}{$Name} = 1;
				}
			}
		}
	unless($DP_OnlyBirthdays) {
		# Process the main calendar content. Here conflicts may arise.
		foreach my $Year (keys(%MainCalendarContent)) {
			foreach my $Month (keys(%{$MainCalendarContent{$Year}})) {
				foreach my $Day (keys(%{$MainCalendarContent{$Year}{$Month}})) {
					foreach my $Time(keys(%{$MainCalendarContent{$Year}{$Month}{$Day}})) {
						my $summary = $MainCalendarContent{$Year}{$Month}{$Day}{$Time}{summary};
						my $fulltext = $MainCalendarContent{$Year}{$Month}{$Day}{$Time}{fulltext};
						my $ConflictText;
						($ConflictText,$Time) = Import_ResolveConflict($Year,$Month,$Day,$Time,$summary,$fulltext);
						if($Time) {
							$CalendarContents{$Year}{$Month}{$Day}{$Time}{summary} = $summary;
							$CalendarContents{$Year}{$Month}{$Day}{$Time}{fulltext} = $fulltext;
						}
						if($ConflictText) {
							push(@Conflicts,$ConflictText);
						}
					}
				}
			}
		}
	}
	return(@Conflicts, $PossibleCorruption);
}

# Purpose: Import data from a day planner data file
# Usage: LoadDayplannerDataFile(FILE);
sub LoadDayplannerDataFile {
	# NOTE: This function MUST be able to work without the GUI initialized
	my $File = $_[0];
	
	# Identify it
	open(READFILE, "<", $File) or do {
		DPIntWarn("Unable to open $File for writing: $!");
		if($MainWindow) {
			DPError(sprintf($Gettext->get("Unable to open %s for writing: %s"), $File, $!));
		}
		return(undef);
	};
	while(<READFILE>) {	# Don't know how to otherwise read only *one* line.
		if($_ =~ /^# Content-type: text\/x-dayplanner$/ ) {
			last;
		} else {
			DPIntWarn("$File does not seem to be a day planner data file");
			if($MainWindow) {
				DPError(sprintf($Gettext->get("%s does not seem to be a day planner data file"), $File));
			}
			return(undef);
		}
	}
	# Data strings
	my($DP_FormatVersion, $DP_Crypt, $DP_DataMD5, $ContainedData, $ContainerMode, $PossibleCorruption);

	# Parse the entire thing
	while(<READFILE>) {
		next unless /\S/;
		chomp;
		unless($ContainerMode) {
			next if /^\s*#/;
			next unless m/=/;
			# Get the values
			my $Name = $_;
			$Name =~ s/^(\w+)\s*=.*$/$1/;
			s/^\w+\s*=\s*//;
			s/;$//;
			if($Name eq 'ContainedData') {
				$ContainedData = $_;
				$ContainerMode = 1;
			} elsif ($Name eq 'DP_FormatVersion') {
				unless($_ =~ /^\s*1\s*$/) {
					DPIntWarn("$File contains version $_ of the day planner data format. This version only supports version 1");
					if($MainWindow) {
						DPError(sprintf($Gettext->get("%s contains version %s of the day planner data format. This version of day planner only supports version 1"), $File, $_));
					}
					return(undef);
				}
			} elsif ($Name eq 'DP_Crypt') {
				$DP_Crypt = $_;
			} elsif ($Name eq 'DP_DataMD5') {
				$DP_DataMD5 = $_;
			} elsif ($Name) {
				DPIntWarn("Unknown setting in data file: $Name (=$_). This might be bad.");
				$PossibleCorruption = 1;
			} else {
				DPIntWarn("Unknown line in data file: $_. This might be bad.");
				$PossibleCorruption = 1;
			}
		} else {
			if(/^#/) {
				$ContainerMode = 0;
			} else {
				$ContainedData .= $_;
			}
		}
	}
	close(READFILE);
	unless(defined($ContainedData)) {
		DPIntWarn("\$ContainedData turned out undef! Corrupt input data?");
		return(undef);
	}
	my (@Conflicts, $Corruption) = DPF_ParseData($ContainedData, $DP_DataMD5, $DP_Crypt);
	$PossibleCorruption = $Corruption ? 1 : $PossibleCorruption;
	if(@Conflicts) {
		my $Message;
		foreach(@Conflicts) {
			$Message .= "$_\n";
		}
		DPInfo($Gettext->get("Conflicting events were detected. Day planner has attempted to resolve the conflicts.\n\nHowever, some of the data may be incorrect or not imported. See the details below for information about the conflicting events."), $Message);
	}
	return(1);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI import/export dialogs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Purpose: Pop up a graphical dialog for importing data
# Usage: ImportData();
sub ImportData {
	$MainWindow->set_sensitive(0);
	# Create the window and VBox
	my $ImportWindow = Gtk2::Window->new();
	$ImportWindow->set_modal(1);
	$ImportWindow->set_transient_for($MainWindow);
	$ImportWindow->set_position('center-on-parent');
	$ImportWindow->set_title($Gettext->get("Import data"));
	$ImportWindow->set_resizable(0);
	$ImportWindow->set_border_width(12);
	$ImportWindow->set_skip_taskbar_hint(1);
	$ImportWindow->set_skip_pager_hint(1);
	$ImportWindow->signal_connect("destroy" => sub {
			$MainWindow->set_sensitive(1);
		});
	my $ImportVBox = Gtk2::VBox->new();
	$ImportWindow->add($ImportVBox);

	# Create the initial text
	my $ImportLabel = Gtk2::Label->new($Gettext->get('Import data from:'));
	$ImportVBox->pack_start($ImportLabel,0,0,0);

	# Create the radio buttons for selection and pack them onto the VBox
	my %StateHash;
	my $ActiveButton = "dayplanner";
	my $DayplannerButton = Gtk2::RadioButton->new (undef, $Gettext->get('From a file (day planner or iCalendar)'));
	my $PlanButton = Gtk2::RadioButton->new ($DayplannerButton, $Gettext->get('From the "plan" software'));
	$ImportVBox->pack_start($DayplannerButton,0,0,0);
	$ImportVBox->pack_start($PlanButton,0,0,0);

	# Add the buttons
	my $ButtonHBox = Gtk2::HBox->new();
	$ButtonHBox->show();
	$ImportVBox->pack_end($ButtonHBox,0,0,0);

	# Ok button
	my $OKButton = Gtk2::Button->new_from_stock('gtk-ok');
	$OKButton->show();
	$OKButton->can_default(1);
	$ImportWindow->set_default($OKButton);
	# Signal callback (starts a function depending on the radio button selected)
	$OKButton->signal_connect("clicked" => sub {
			$ImportWindow->destroy();
			if($DayplannerButton->get_active) {
				ImportDataFromFile();
			} elsif ($PlanButton->get_active) {
				MigratePlan(0);
			} else {
				DPIntWarn("Unknown active button!\n");
			}
		});
	$ButtonHBox->pack_end($OKButton,0,0,0);

	# Cancel button
	my $CancelButton = Gtk2::Button->new_from_stock('gtk-cancel');
	$CancelButton->show();
	$ButtonHBox->pack_end($CancelButton,0,0,0);
	# Signal callback (destroys the window)
	$CancelButton->signal_connect("clicked" => sub {
			$ImportWindow->destroy();
		});

	# Add tooltips
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->set_tip($DayplannerButton, $Gettext->get("Import data from a day planner data file"));
	$Tooltips->set_tip($PlanButton, $Gettext->get("Import data from the \"plan\" program."));
	$Tooltips->set_tip($CancelButton, $Gettext->get('Cancel importing and return to day planner'));
	$Tooltips->set_tip($OKButton, $Gettext->get('Import the selected data'));

	# Show it all
	$Tooltips->enable();
	$DayplannerButton->show();
	$PlanButton->show();
	$ImportLabel->show();
	$ImportVBox->show();
	$ImportWindow->show();
}

# Purpose: Pop up a file picker to find the file to import
# Usage: ImportDataFromFile();
sub ImportDataFromFile {
	# NOTE: We currently rely upon file extensions. This might actually be fine
	# but this note is left as a little heads up. As we filter on filenames anyway
	# the only case would be a file named *.ics which should be *.dpf or the other
	# way around.
	# Create the main window
	my $ImportWindow = Gtk2::FileChooserDialog->new("Import data from file", $MainWindow, 'open',
	'gtk-cancel' => 'reject',
	'gtk-open' => 'accept',);
	$ImportWindow->set_local_only(1);
	$ImportWindow->set_default_response('accept');
	my $filter = Gtk2::FileFilter->new;
	$filter->add_pattern('*.dpf');
	$filter->add_pattern('*.ics');
	$filter->set_name($Gettext->get('All supported file formats'));
	$ImportWindow->add_filter($filter);
	my $Response = $ImportWindow->run();
	if($Response eq 'accept') {
		my $Filename = $ImportWindow->get_filename();
		if($Filename =~ /\.dpf$/i) {
			LoadDayplannerDataFile($Filename);
			UpdatedData();
		} elsif($Filename =~ /\.ics$/i) {
			iCal_ImportFile($Filename);
			UpdatedData();
			DPInfo($Gettext->get("Day planner has imported the iCalendar data as well as it can.\n\nNote however that day planner does not support all functions present in the iCalendar format so some data may have been lost."));
		} else {
			DPIntWarn("Unknown filetype: $Filename");
		}
	}
	$ImportWindow->destroy();
}

# Purpose: Pop up a graphical dialog for exporting data
# Usage: ExportData();
sub ExportData {
	# Create the main window
	my $ExportWindow = Gtk2::FileChooserDialog->new($Gettext->get("Export data"), $MainWindow, 'save',
	'gtk-cancel' => 'reject',
	'gtk-save' => 'accept',);
	$ExportWindow->set_current_name($Gettext->get("My_dayplanner"));
	$ExportWindow->set_local_only(1);

	# Create the file format selection part
	my $ExportHBox = Gtk2::HBox->new();
	$ExportHBox->show();
	my $ExportVBox = Gtk2::VBox->new();
	$ExportVBox->show();
	$ExportWindow->set_extra_widget($ExportVBox);
	$ExportVBox->pack_start($ExportHBox,0,0,0);

	# Encryption checkbox
	my $EncryptionCheckbox = Gtk2::CheckButton->new($Gettext->get("Password protect the file (encryption)"));
	$EncryptionCheckbox->show();
	$ExportVBox->pack_end($EncryptionCheckbox,0,0,0);
	# Only birthdays checkbox
	my $BirthdaysOnlyCheckbox = Gtk2::CheckButton->new($Gettext->get("Only export birthdays"));
	$BirthdaysOnlyCheckbox->show();
	$ExportVBox->pack_end($BirthdaysOnlyCheckbox,0,0,0);

	# Label
	my $ActiveIndex;
	my $FiletypeLabel = Gtk2::Label->new($Gettext->get("Save as filetype:"));
	$FiletypeLabel->set_justify('left');
	$FiletypeLabel->show();
	$ExportHBox->pack_start($FiletypeLabel,0,0,0);
	# Combo selector
	my $Export_Combo = Gtk2::ComboBox->new_text;
	$Export_Combo->insert_text(0, sprintf($Gettext->get('Day planner data format (%s)'), '*.dpf'));
	$Export_Combo->insert_text(1, 'iCalendar (*.ics)');
	$Export_Combo->insert_text(2,         $Gettext->get('XHTML (exports to a directory)'));
	$ExportHBox->pack_end($Export_Combo,0,0,0);
	$Export_Combo->show();

	# Handle changed values in the combo box
	$Export_Combo->signal_connect('changed' => sub {
		$ActiveIndex = $Export_Combo->get_active();
		unless($ActiveIndex == 0) {
			$EncryptionCheckbox->set_sensitive(0);
		} else {
			$EncryptionCheckbox->set_sensitive(1);
		}
		if($ActiveIndex == 2) {
			$BirthdaysOnlyCheckbox->set_sensitive(0);
			$ExportWindow->set_action('select-folder');
		} else {
			$BirthdaysOnlyCheckbox->set_sensitive(1);
			$ExportWindow->set_action('save');
		}
	});
	$Export_Combo->set_active(0);

	while (1) {
		my $Response = $ExportWindow->run();
		my $Filename = $ExportWindow->get_filename();
		if($Response eq 'accept') {
			my $OnlyBirthdays = $BirthdaysOnlyCheckbox->get_active();
			if($ActiveIndex == 0) {
				if(PromptOverwrite("$Filename.dpf")) {
					my $Encrypt = $EncryptionCheckbox->get_active();
					WriteDayplannerDataFile("$Filename.dpf",$OnlyBirthdays,$Encrypt);
					last;
				}
			} elsif ($ActiveIndex == 1) {
				if(PromptOverwrite("$Filename.ics")) {
					iCal_Exporter("$Filename.ics", $OnlyBirthdays);
					last;
				}
			} elsif ($ActiveIndex == 2) {
				if(PromptOverwrite($Filename, 1)) {
					HTML_Export($Filename);
					last;
				}
			} else {
				DPIntWarn("Unknown activeindex: $ActiveIndex");
			}
		} else {
			last;
		}
	}
	$ExportWindow->destroy();
}

# Purpose: Prompt the user to overwrite data
# Usage: PromptOverwrite(PATH, DIR?);
# 	Returns undef on "don't overwrite". Otherwise true.
sub PromptOverwrite {
	my ($File, $Dir) = @_;
	if($Dir) {
		if(-e $File) {
			if(-d $File) {
				foreach(<$File/*>) {
					unless($_ =~ /^\./) {
						if(DPQuestion(sprintf($Gettext->get("There are already files in the directory \"%s\". If you continue any existing exported day planner data in that directory will be overwritten. Do you want to continue?"), $File))) {
							return(1);
						} else {
							return(undef);
						}
					}
				}
				return(1);
			} else {
				DPInfo(sprintf($Gettext->get("\"%s\" already exists and is not a directory."), $File));
				return(undef);
			}
		} else {
			return(1);
		}
	} else {
		my $FileDirname = dirname($File);
		unless(-w $FileDirname) {
			DPInfo(sprintf($Gettext->get("\"%s\" is read only. Write permissions are required."), $FileDirname));
			return(undef);
		}
		if(-e $File) {
			if(-d $File) {
				DPInfo(sprintf($Gettext->get("\"%s\" is a directory.")));
				return(undef);
			} elsif(DPQuestion(sprintf($Gettext->get("\"%s\" already exists. Overwrite?"), $File))) {
				return(1);
			} else {
				return(undef);
			}
		} else {
			return(1);
		}
	}
}

# =============================================================================
# GUI CODE
# =============================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI helper functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Initialize gtk2
# Usage: Gtk2Init();
sub Gtk2Init {
	Gtk2->init();
	$Gtk2Init = 1;
}

# Purpose: Create a progresswindow
# Usage: my $ProgressWin = DPCreateProgressWin(WINDOW NAME, INITIAL PROGRESS BAR TEXT, PULSATE_MODE?);
# 	Returns a hashref with the following keys:
# 		Window = The window
# 		ProgressBar = The progress bar
sub DPCreateProgressWin {
	my ($Name, $Text, $PulsateMode) = @_;
	my %ProgressHash;
	$ProgressHash{Window} = Gtk2::Window->new();
	if(defined($Name)) {
		$ProgressHash{Window}->set_title($Name);
	}
	if(defined($MainWindow)) {
		$ProgressHash{Window}->set_transient_for($MainWindow);
		$ProgressHash{Window}->set_position('center-on-parent');
	} else {
		$ProgressHash{Window}->set_position('center');
	}
	$ProgressHash{ProgressBar} = Gtk2::ProgressBar->new();
	$ProgressHash{Window}->add($ProgressHash{ProgressBar});
	$ProgressHash{Window}->set_modal(1);
	$ProgressHash{Window}->set_resizable(0);
	if(defined($Text)) {
		$ProgressHash{ProgressBar}->set_text($Text);
	}
	if($PulsateMode) {
		$ProgressHash{ProgressBar}->{activity_mode} = 0;
	}
	$ProgressHash{ProgressBar}->show();
	$ProgressHash{Window}->show();
	Gtk2->main_iteration while Gtk2->events_pending;
	Gtk2->main_iteration while Gtk2->events_pending;
	Gtk2->main_iteration while Gtk2->events_pending;
	return(\%ProgressHash);
}

# Purpose: Pulsate a progressbar
# Usage: PulsateProgressbar($Progressbar);
sub PulsateProgressbar {
	my $Progressbar = $_[0];
	if(defined($Progressbar)) {		# So that the calling function can just *assume* it has a progressbar
						# even when it doesn't
		$Progressbar->pulse();
		Gtk2->main_iteration while Gtk2->events_pending;
	}
	return(1);
}

# Purpose: Populate the upcoming events widget
# Usage: PopulateUpcomingEvents();
sub PopulateUpcomingEvents {
	my $NewUpcoming;
	my $HasUpcoming;
	my %InformationHash;
	my %DayNames = (
		0 => $Gettext->get("Sunday"),
		1 => $Gettext->get("Monday"),
		2 => $Gettext->get("Tuesday"),
		3 => $Gettext->get("Wednesday"),
		4 => $Gettext->get("Thursday"),
		5 => $Gettext->get("Friday"),
		6 => $Gettext->get("Saturday")
	);

	# Today is
	my ($getsec,$getmin,$gethour,$getmday,$getmonth,$getyear,$getwday,$getyday,$getisdst) = localtime(time);
	my $Year = $getyear;

	# Prepare
	my $TheYday = $getyday;
	my $FirstDay = 1;
	my $AddDays = 7;
	$TheYday++; # Yearday currently starts at 0, we need it to start at 1

	# Loop used to populate the %InformationHash
	while($AddDays) {
		$TheYday++;	# This is a new day
		$AddDays--;	# One less day to add

		$InformationHash{$TheYday} = {};
		my $h = $InformationHash{$TheYday};
		
		my $Mktime = POSIX::mktime(0, 0, 0, $TheYday, 0, $Year);	# Get the POSIX time of this day

		my ($getsec,$getmin,$gethour,$getmday,$getmonth,$getyear,$getwday,$getyday,$getisdst) = localtime($Mktime);	# Get the real time of this day
		$getmonth++;	# Month should be 1-12 not 0-11

		my $HumanYear = $getyear+1900;	# Human readable year

		if($FirstDay) {
			$h->{text}= $Gettext->get("Tomorrow");
			$h->{dayname} = $h->{text};
			$FirstDay = 0;
		} else {
			$h->{text} .= "\n\n";
			$h->{text} .= $DayNames{$getwday};
			$h->{dayname} = $DayNames{$getwday};
		}
		$h->{date} = "$getmday.$getmonth.$HumanYear";
		$h->{text} .= " ($getmday.$getmonth.$HumanYear) :";
		my $HasEvents;
		if(CalendarDayDefined($Year+1900, $getmonth, $getmday)) {
			foreach(keys(%{$CalendarContents{$HumanYear}{$getmonth}{$getmday}})) {
				$HasEvents = 1;
				$h->{text} .= "\n" . $Gettext->get("At") . " " . AMPM_From24($_) . ": $CalendarContents{$HumanYear}{$getmonth}{$getmday}{$_}{summary}";
			}
		}
		if(BirthdayDayDefined($getmonth, $getmday)) {
			foreach my $Birthday (keys(%{$BirthdayContents{$getmonth}{$getmday}})) {
					$HasEvents = 1;
					$h->{text} .= "\n" .  sprintf($Gettext->get("%s's birthday"), $Birthday);
			}
		}
		unless($HasEvents) {
			$h->{text} .= $Gettext->get("(nothing)");
			$h->{noevents} = 1;
		} else {
			$HasUpcoming = 1;
		}

	}
	unless($HasUpcoming) {
		$NewUpcoming = $Gettext->get("No upcoming events exist for the next seven days");
	} else {
		my $LoopNum;
		# Remove duplicate (nothing)'s
		foreach my $key (sort(keys(%InformationHash))) {
			# If the key doesn't exist (any more) or doesn't have noevents then skip it
			next unless(defined($InformationHash{$key}));
			$LoopNum++;		# Up the loop counter
			next unless(defined($InformationHash{$key}{noevents}));
			# Find out which key is next
			my $Next = $key;
			$Next++;
			# Skip if the next key doesn't have noevents set
			next unless(defined($InformationHash{$Next}) and defined($InformationHash{$Next}{noevents}));

			my @OtherNoevents;	# Array of the next keys without any events
			my $LastDate;
			my $LastDay;		# The last day with noevents

			# For each of the next dates with no events set it up for usage here and if we had another
			# noevents before this push it onto the @OtherNoevents array and replace the $LastDay value
			# with ours.
			while(defined($InformationHash{$Next}) and defined($InformationHash{$Next}{noevents})) {
				$LastDate = $InformationHash{$Next}{date};
				if(defined($LastDay)) {
					push(@OtherNoevents, $LastDay);
				}
				$LastDay = $Next;
				$Next++;
			}
			# Reset the current text 
			if($LoopNum > 1) {
				$InformationHash{$key}{text} = "\n\n";
			} else {
				$InformationHash{$key}{text} = "";
			}
			# If there is something in @OtherNoevents then do more processing
			if(@OtherNoevents) {
				# First day (current key)
				$InformationHash{$key}{text} .= "$InformationHash{$key}{dayname},";

				my $Counter;	# Count how many times we've gone through the foreach
				foreach(@OtherNoevents) {
					$Counter++;	# Up the counter
					$InformationHash{$key}{text} .= " $InformationHash{$_}{dayname}";
					unless($Counter eq scalar(@OtherNoevents)) {	# If the counter doesn't equal the number of entries
											# in the array then append a comma.
						$InformationHash{$key}{text} .= ",";
					}
					# Delete the key
					delete($InformationHash{$_});
				}
				# Append the last entries
				$InformationHash{$key}{text} .= " " . $Gettext->get("and") . " $InformationHash{$LastDay}{dayname}";
			} else {
				# Build the string
				$InformationHash{$key}{text} .= "$InformationHash{$key}{dayname} " . $Gettext->get("and") . " $InformationHash{$LastDay}{dayname}";
			}
			# Delete the $LastDay key
			delete($InformationHash{$LastDay});
			# Finalize the string
			$InformationHash{$key}{text} .= " ($InformationHash{$key}{date}-$LastDate): " . $Gettext->get("(nothing)");
		}
		# Build our $NewUpcoming
		foreach my $key(sort(keys(%InformationHash))) {
			$NewUpcoming .= $InformationHash{$key}{text};
		}
	}
	# Don't update the widget if the text hasn't changed
	unless($UpcomingEventsWidget->get_buffer eq $NewUpcoming) {
		$UpcomingEventsBuffer->set_text($NewUpcoming);
	}
}

# Purpose: Wrapper around AddAutostart that detects if we have an pre-2.14
# 		version of GNOME and displays an information dialog about the
# 		inability to add a gnome autostart
# Usage: DP_AddAutostart();
sub DP_AddAutostart {
	my $GNOME_Version;
	my $Old_GNOME;

	# Set the settings var
	$InternalConfig{AutostartOn} = 1;

	# Try to get the gnome version from the gnome control center
	foreach(split(/:/, sprintf("%s:%s", dirname(Cwd::realpath($0)), $ENV{PATH} ))) {
		if (-x "$_/gnome-control-center") {
			$GNOME_Version = qx#$_/gnome-control-center --version#;
			chomp($GNOME_Version);
			$GNOME_Version =~ s/^(.+)\s+(.+)\s+(.+)$/$3/;
			$GNOME_Version =~ s/^(\d+\.\d+).*$/$1/;
			$GNOME_Version = undef unless($GNOME_Version =~ /^\d+\.\d+(\.\d+.*)?$/);
			last;
		}
	}
	if(defined($GNOME_Version)) {
		unless($GNOME_Version > 2.12) {
			$Old_GNOME = 1;
		} else {
			$Old_GNOME = 0;
		}
	} else {	# If we couldn't get the GNOME version then we just assume the user 
			# either doesn't use GNOME or has a version of GNOME newer than 2.12
		$Old_GNOME = 0;
	}

	my $Result = AddAutostart($Old_GNOME);
	return(1) if $Result =~ /^okay$/;

	if($Result =~ /^gnome-fail$/) {
		# GNOME failed, check if GNOME_DESKTOP_SESSION_ID is set.
		# If it isn't set, then the user isn't running GNOME *now* so we don't want to display the
		# error.
		if(defined($ENV{GNOME_DESKTOP_SESSION_ID}) and length($ENV{GNOME_DESKTOP_SESSION_ID})) {
			# It's set, so the user is running GNOME - display the error
			DPError($Gettext->get("A problem occurred while setting up automatic startup of the day planner reminder.\n\nSet it up manually by selecting: menu -> desktop -> settings -> sessions. From there select \"Startup Programs\", click \"Add\". Type \"dayplanner-daemon\" in the \"Startup Command\" field and press the \"OK\" button."));
		}
	} else {
		DPIntWarn("Unknown return value from AddAutostart(): $Result");
	}
	return(1);
}

# Purpose: Wrapper around RemoveAutostart that sets the config vars
# Usage: DP_RemoveAutostart();
sub DP_RemoveAutostart {
	if(DPQuestion($Gettext->get("Disabling automatic startup of the reminder will prevent notifications unless day planner has been manually started. Disable the automatic startup?"))) {
		$InternalConfig{AutostartOn} = 1;
		return(RemoveAutostart());
	}
	return(undef);
}

# Purpose: Detect the path to the image file(s) supplied. Returns the path to the
# 		first one found or undef
# Usage: $Image = DetectImage(image1, image2);
sub DetectImage {
	my $I_Am_At = dirname(Cwd::realpath($0));
	foreach my $Image (@_) {
		foreach my $Dir ("$I_Am_At/art", $I_Am_At, "/usr/share/dayplanner", "/usr/local/dayplanner", "/usr/local/share/dayplanner", "/usr/share/dayplanner/art", "/usr/local/dayplanner/art", "/usr/local/share/dayplanner/art", "/usr/share/icons/large", "/usr/share/icons", "/usr/share/icons/mini") {
			if (-e "$Dir/$Image") {
				return("$Dir/$Image");
			}
		}
	}
	return(undef);
}

# Purpose: Delete the event currently selected in the eventlist
# Usage: DeleteEvent();
#  (calls CalendarDelete/BirthdayDelete with the correct parameters)
sub DeleteEvent {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# Unless $Selected is defined we don't have anything selected in the eventlist
	unless(defined($Selected)) {
		DPIntWarn("DeletEvent() called without any event selected");
		return(0);
	}
	my $Type = GetEventListType();
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my $EventTime = $EventlistWidget->{data}[$Selected][0];
	my $EventSummary = $EventlistWidget->{data}[$Selected][1];

	if($Type eq 'normal') {
		if (defined($EventTime)) {
			CalendarDelete($EventYear,$EventMonth,$EventDay,AMPM_To24($EventTime));
			UpdatedData();
		} else {
			DPIntWarn("DeleteEvent() didn't find the event time of the event to be deleted");
		}
	} elsif ($Type eq 'bday') {
		if (defined($EventSummary)) {
			BirthdayDelete($EventMonth, $EventDay, GetRealBirthdayName($EventSummary));
			UpdatedData();
		} else {
			DPIntWarn("DeleteEvent() didn't find the name of the person whose birthday it was suppose to delete");
		}
	} else {
		DPIntWarn("DeleteEvent: Attempted to handle unsupported \$Type: $Type");
	}
}

# Purpose: Get the real name of the person whose birthday it is
# Usage: my $Name = GetRealBirthdayName(NAME);
sub GetRealBirthdayName {
	my $Name = $_[0];
	my $BirthdayString = $Gettext->get("%s's birthday");
	$BirthdayString =~ s/%s//;
	$Name =~ s/$BirthdayString$//;
	return($Name);
}

# Purpose: Detect which kind of event is selected in the eventlist
# Usage: my $Type = GetEventListType();
sub GetEventListType {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# If $Selected isn't defined then nothing *is* selected and thus we just return (false)
	unless(defined($Selected)) {
		return(0);
	}
	# Initialize
	my $Time = $EventlistWidget->{data}[$Selected][0];
	my $Summary = $EventlistWidget->{data}[$Selected][1];
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;

	my $BirthdayString = $Gettext->get("%s's birthday");
	$BirthdayString =~ s/%s//g;

	# Detect the event type
	if (defined($Time) and length($Time)) {
		return('normal');
	} elsif (defined($Summary) and length($Summary) and $Summary =~ /$BirthdayString/) {
		return('bday')
	} elsif (defined($Summary) and length($Summary)) {
		return('holiday')
	} else {
		DPIntWarn("FATAL: GetEventListType: Unable to get the type of the selected event ($EventYear-$EventMonth-$EventDay-$Time/$Summary");
		return(0);
	}
}

# Purpose: Close a window when the escape key is pressed
# Usage: $WIDGET->signal_connect("key_release_event" => \&EscapeKeyHandler);
sub EscapeKeyHandler {
	my ($widget, $event) = @_;
	if ($event->keyval == $Gtk2::Gdk::Keysyms{Escape}) {
		$widget->destroy();
	}
}

# Purpose: Display an error dialog
# Usage: DPError("Error message");
sub DPError {
	if($Gtk2Init) {
		my $Dialog = Gtk2::MessageDialog->new($MainWindow, "modal", 'error', 'ok', "$_[0]");
		$Dialog->run();
		$Dialog->destroy();
	} else {
		warn($_[0]);
	}
	return(1);
}

# Purpose: Display a warning dialog
# Usage: DPWarning("Warning");
sub DPWarning {
	if($Gtk2Init) {
		my $Dialog = Gtk2::MessageDialog->new_with_markup($MainWindow, "modal", 'warning', 'ok', "$_[0]");
		$Dialog->run();
		$Dialog->destroy();
	} else {
		warn($_[0]);
	}
	return(1);
}

# Purpose: Display an information dialog (with optional details)
# Usage: DPInfo("Information message", details?);
sub DPInfo {
	if($Gtk2Init) {
		my $Dialog = Gtk2::MessageDialog->new($MainWindow, "modal", 'info', 'ok', "$_[0]");
		if($_[1]) {
			# The expander
			my $FT_Expander = Gtk2::Expander->new($Gettext->get("Details"));
			$FT_Expander->show();
			$Dialog->vbox->add($FT_Expander);
			# The textview field
			my $FulltextView = Gtk2::TextView->new();
			$FulltextView->set_editable(0);
			$FulltextView->set_wrap_mode("word-char");
			$FulltextView->show();
			# Add the text to it
			my $FulltextBuffer = Gtk2::TextBuffer->new();
			$FulltextBuffer->set_text($_[1]);
			$FulltextView->set_buffer($FulltextBuffer);
			# Create a scrollable window to use
			my $FulltextWindow = Gtk2::ScrolledWindow->new;
			$FulltextWindow->set_policy('automatic', 'automatic');
			$FulltextWindow->add($FulltextView);
			$FulltextWindow->show();
			# Add it to the expander
			$FT_Expander->add($FulltextWindow);
		}
		$Dialog->run();
		$Dialog->destroy();
	} else {
		print "$_[0]\n";
		if(defined($_[1])) {
			print "$_[1]\n";
		}
	}
}

# Purpose: Display a question dialog
# Usage: DPQuestion("Question");
# 	Returns true on yes, false on anything else
sub DPQuestion {
	my $Dialog = Gtk2::MessageDialog->new(undef, "modal", 'question', 'yes-no', $_[0]);
	my $Reply = $Dialog->run();
	$Dialog->destroy();
	if ($Reply eq 'yes') {
		return(1);
	} else {
		return(0);
	}
}

# Purpose: Call save functions on exit
# Usage: QuitSub();
sub QuitSub {
	$MainWindow->set_sensitive(0);
	DPS_GUIPerform("SEND");
	my $SaveData = SaveMainData();
	if ($SaveData eq 'SAVE_FAILED') {
		unless(DPQuestion($Gettext->get("Some files could not be saved correctly. Quit anyway?"))) {
			$MainWindow->show();
			return(1);
		}
	} elsif ($SaveData eq 'DAEMON_RELOAD_FAILURE') {
		unless(DPQuestion($Gettext->get("Quit anyway?"))) {
			$MainWindow->show();
			return(1);
		}
	}
	
	WriteStateFile($SaveToDir, "state.conf");
	
	Gtk2->main_quit;
	CloseDaemon();
	exit(0);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI calendar functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Sets the active calendar items in the $CalendarWidget
# Usage: SetActiveCalItems(YEAR, NUMERICAL_MONTH[1-12]);
sub SetActiveCalItems {
	$CalendarWidget->clear_marks;			# Clear the current marks
	# Calendar contents
	if (defined($CalendarContents{$_[0]}) and defined($CalendarContents{$_[0]}{$_[1]})) {
		foreach my $Day (keys %{$CalendarContents{$_[0]}{$_[1]}}) {
			$CalendarWidget->mark_day($Day);	# Mark this day
		}
	}
	# Birthdays
	if (defined($BirthdayContents{$_[1]})) {
		foreach my $Day (keys %{$BirthdayContents{$_[1]}}) {
			$CalendarWidget->mark_day($Day);	# Mark this day
		}
	}
}

# Purpose: Sets the date/time variables to the current date/time
# Usage: GetDate();
sub GetDate {
	($currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst) = localtime(time);
	$curryear += 1900;						# Fix the year format
	$currmonth++;							# Fix the month format
}

# Purpose: Calls SetActiveCalItems on the current year/month displayed in the $CalendarWidget
# Usage: CalendarChange();
sub CalendarChange {
	my $Month = $CalendarWidget->month;
	$Month++;
	SetActiveCalItems($CalendarWidget->year, $Month);
}

# Purpose: Get the day, month and year in a single string from a calendar
# Usage: my $Date = Get_DateInfo($CALWIDGET);
sub Get_DateInfo {
	my ($year, $month, $day) = $CalendarWidget->get_date();
	return("$year$month$day");
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI event adding and editing functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Get a properly formatted event time from two widgets (min/hour)
# Usage: my $Time = GetTimeFromWidgets($HourSpinner, $MinuteSpinner, $AMPM);
sub GetTimeFromWidgets {
	# In the future this sub will take a third argument, which is either an AM/PM
	# selection box, or undef - so that seamless AM/PM support is needed.
	
	my ($HourSpinner, $MinuteSpinner, $AMPM) = @_;	
	my $Hour = $HourSpinner->get_value_as_int();
	my $Minute = $MinuteSpinner->get_value_as_int();
	if ($Hour <= 9) {
		$Hour = "0$Hour";
	}
	if ($Minute <= 9) {
		$Minute = "0$Minute";
	}
	if(defined($AMPM)) {
		my $Prefix;
		if($AMPM->get_active() == 0) {
			$Prefix = $AM_String;
		} else {
			$Prefix = $PM_String;
		}
		($Hour,$Minute) = AMPM_To24("$Hour:$Minute $Prefix", 1);
	}
	return("$Hour:$Minute");
}

# Purpose: Create the widgets for selecting the time
# Usage: my ($HourSpinner, $MinuteSpinner, $TimeHBox, $AMPM) = TimeSelection("HH:MM");
sub TimeSelection {
	my $Time = $_[0];
	my($HourAdjustment,$MinuteAdjustment, $HourSpinner,$MinuteSpinner,$AMPM);

	if($ClockSystem == 24) {
		# The hour adjustment
		$HourAdjustment = Gtk2::Adjustment->new(0.0, 0.0, 23.0, 1.0, 5.0, 0.0);
	} else {
		# The hour adjustment
		$HourAdjustment = Gtk2::Adjustment->new(0.0, 1.0, 12.0, 1.0, 5.0, 0.0);
	}
	# The minute adjustment
	$MinuteAdjustment = Gtk2::Adjustment->new(0.0, 0.0, 59.0, 1.0, 5.0, 0.0);
	# Create the spinners
	$HourSpinner = Gtk2::SpinButton->new($HourAdjustment, 0, 0);
	$MinuteSpinner = Gtk2::SpinButton->new($MinuteAdjustment, 0, 0);
	# Show them
	$HourSpinner->show();
	$MinuteSpinner->show();
	
	# Create a simple seperating label
	my $TimeSeperatorLabel = Gtk2::Label->new(' : ');
	$TimeSeperatorLabel->show();
	
	# Make them activate the default action
	$HourSpinner->set_activates_default(1);
	$MinuteSpinner->set_activates_default(1);
	
	if($ClockSystem == 24) {
		# Get the time
		my $HSTime = $Time;		# Hour
		my $MSTime = $Time;		# Minute
		$HSTime =~ s/^(\d+):\d+$/$1/;
		$MSTime =~ s/^\d+:(\d+)$/$1/;
		# Set the initial value
		$HourSpinner->set_value($HSTime);
		$MinuteSpinner->set_value($MSTime);
	} else {
		# Get the time
		my $HSTime = AMPM_From24($Time);
		my $MSTime = AMPM_From24($Time);
		my $Suffix = AMPM_From24($Time);
		$HSTime =~ s/^(\d+):.*$/$1/;
		$MSTime =~ s/^\d+:(\d+).*$/$1/;
		$Suffix =~ s/^\d+:\d+\s+(.+)/$1/;
		# Set the initial value
		$HourSpinner->set_value($HSTime);
		$MinuteSpinner->set_value($MSTime);
		# Create the combo box
		$AMPM = Gtk2::ComboBox->new_text;
		$AMPM->insert_text(0, $AM_String);
		$AMPM->insert_text(1, $PM_String);
		$AMPM->show();
		# Set the initial value
		if($Suffix eq $AM_String) {
			$AMPM->set_active(0);
		} else {
			$AMPM->set_active(1);
		}
	}
	
	# Create a HBox and pack them onto it
	my $TimeSpinnerHBox = Gtk2::HBox->new(0,0);
	$TimeSpinnerHBox->pack_start($HourSpinner,0,0,0);
	$TimeSpinnerHBox->pack_start($TimeSeperatorLabel,0,0,0);
	$TimeSpinnerHBox->pack_start($MinuteSpinner,0,0,0);
	if(defined($AMPM)) {
		$TimeSpinnerHBox->pack_start($AMPM,0,0,0);
	}
	$TimeSpinnerHBox->show();

	# Return the widgets
	return($HourSpinner, $MinuteSpinner, $TimeSpinnerHBox, $AMPM);
}

# Purpose: Create the window that will contain the event editor
# Usage: my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin(TITLE, LABEL, OK_BUTTON_TYPE);
#
# TITLE is the title of the window, LABEL is the label to display on top of the window.
# OK_BUTTON_TYPE is the Gtk2::Stock ID to use for the button
sub CreateEventContainerWin {
	# Get the options passed to the sub
	my ($WindowTitle, $EventLabel, $OkButtonType) = @_;
	
	# Get the date
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;

	# ==================================================================
	# BUILD THE WINDOW
	# ==================================================================
	my $AddEventBox = Gtk2::Window->new();
	$AddEventBox->set_modal(1);
	$AddEventBox->set_transient_for($MainWindow);
	$AddEventBox->set_position('center-on-parent');
	$AddEventBox->set_title($WindowTitle);
	$AddEventBox->set_resizable(0);
	$AddEventBox->set_border_width(5);
	$AddEventBox->set_skip_taskbar_hint(1);
	$AddEventBox->set_skip_pager_hint(1);

	# Handle closing
	$AddEventBox->signal_connect("destroy" => sub { $AddEventBox->destroy; $MainWindow->set_sensitive(1) });
	$AddEventBox->signal_connect("delete-event" => sub { $AddEventBox->destroy; $MainWindow->set_sensitive(1) });
	
	# Primary vbox
	my $ADPrimVBox = Gtk2::VBox->new();
	$AddEventBox->add($ADPrimVBox);
	$ADPrimVBox->show();
	
	# Add the label with the name
	my $DateLabel = Gtk2::Label->new(sprintf($EventLabel,$EventDay, $MonthNames{$EventMonth},$EventYear));
	$DateLabel->show();
	$ADPrimVBox->pack_start($DateLabel,1,0,0);
	
	# The HBox for the frame
	my $FrameHBox = Gtk2::HBox->new();
	$FrameHBox->show();
	$ADPrimVBox->pack_start($FrameHBox,1,1,0);
	
	# Create the frame
	my $TBFrame = Gtk2::Frame->new();
	$TBFrame->set_label($Gettext->get("Event"));
	$FrameHBox->pack_start($TBFrame,1,1,0);
	$TBFrame->show();
	
	# TODO: Add a pop-up where you can select the date (DatePopup())
	
	# Create the vbox for use in the frame
	my $TBVBox = Gtk2::VBox->new();
	$TBFrame->add($TBVBox);
	$TBVBox->show();
	
	# ==================================================================
	# Call the functions that constructs the main window contents
	# ==================================================================
	
	# Create the hbox for the buttons
	my $TB_ButtonHBox = Gtk2::HBox->new(0,6);
	$TB_ButtonHBox->show();
	$ADPrimVBox->pack_end($TB_ButtonHBox,0,0,0);
	
	# Create the OK button
	my $OKButton = Gtk2::Button->new_from_stock($OkButtonType);
	$OKButton->show();
	$TB_ButtonHBox->pack_end($OKButton,0,0,0);
	$OKButton->can_default(1);

	# Create the cancel button
	my $CancelButton = Gtk2::Button->new_from_stock('gtk-cancel');
	$CancelButton->signal_connect("clicked" => sub { $AddEventBox->destroy;
		});
	$CancelButton->show();
	$TB_ButtonHBox->pack_end($CancelButton,0,0,0);
	
	# Handle the esc button
	$AddEventBox->signal_connect("key_release_event" => \&EscapeKeyHandler);
	$AddEventBox->set_default($OKButton);

	# Return the widgets
	return($AddEventBox, $TBVBox, $OKButton, $CancelButton);
}

# Purpose: Add a event. Creates the main window and calls the proper event functions
# Usage: AddEvent();
sub AddEvent {
	$MainWindow->set_sensitive(0);
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my $OKSignal;
	my %TimeHash = (
		EventYear => $EventYear,
		EventMonth => $EventMonth,
		EventDay => $EventDay,
	);
		
	# Create the main window with the appropriate OK/Cancel buttons and the event frame
	my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Add an event"), $Gettext->get('Adding an event on the %s. %s %s'), 'gtk-add');
	# HBox
	my $SelectorHBox = Gtk2::HBox->new();
	$VBox_HBoxContainer->pack_start($SelectorHBox,0,0,0);
	$SelectorHBox->show();
	# Label
	my $EventTypeLabel = Gtk2::Label->new($Gettext->get("Event type:"));
	$SelectorHBox->pack_start($EventTypeLabel,0,0,0);
	$EventTypeLabel->show();
	# Combo selector
	my $EventType_Combo = Gtk2::ComboBox->new_text;
	$EventType_Combo->insert_text(0, $Gettext->get("Normal"));
	$EventType_Combo->insert_text(1, $Gettext->get("Birthday"));
	$SelectorHBox->pack_start($EventType_Combo,0,0,0);
	$EventType_Combo->show();

	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	# Set the tooltips
	$Tooltips->set_tip($OKButton, $Gettext->get("Add this event"));
	$Tooltips->set_tip($CancelButton, $Gettext->get("Discard this event"));
	
	# Create the widgets for the normal event selection
	my ($NE_MainWidget, $NE_HourSpinner, $NE_MinuteSpinner, $NE_AMPM, $NE_SummaryWidget, $NE_DetailsWidget) = NormalEventWindow("NULL", $OKButton, $VBox_HBoxContainer, $Window);
	# Create the widgets for the birthday event selection
	my ($BE_MainWidget, $BE_NameWidget) = BirthdayEventWindow(undef, $VBox_HBoxContainer, $Window);

	# Handle changed values in the combo box
	$EventType_Combo->signal_connect('changed' => sub {
			my $ActiveIndex = $EventType_Combo->get_active;
			if ($ActiveIndex == 0) {
				$BE_MainWidget->hide();
				$NE_MainWidget->show();
				$OKButton->signal_handler_disconnect($OKSignal) if defined($OKSignal);
				$OKSignal = $OKButton->signal_connect('clicked' => sub {
					NormalEvent_OK($Window, $NE_HourSpinner, $NE_MinuteSpinner, $NE_AMPM, $NE_SummaryWidget, $NE_DetailsWidget, \%TimeHash, 0);
				});
			} elsif ($ActiveIndex == 1) {
				$NE_MainWidget->hide();
				$BE_MainWidget->show();
				$OKButton->signal_handler_disconnect($OKSignal) if defined($OKSignal);
				$OKSignal = $OKButton->signal_connect('clicked' => sub {
					BirthdayEvent_OK($Window, $BE_NameWidget, \%TimeHash, 0)});
			}
		});

	$EventType_Combo->set_active(0);
	
	# Show the window
	$Window->show();
}

# Purpose: Edit the event currently selected in the eventlist
# Usage: EditEvent ();
sub EditEvent {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# If $Selected isn't defined then nothing *is* selected and thus we just return (false)
	unless(defined($Selected)) {
		DPIntWarn("EditEvent() called with no event selected");
		return(0);
	}
	
	$MainWindow->set_sensitive(0);

	# Initialize
	my $Time = AMPM_To24($EventlistWidget->{data}[$Selected][0]);
	my $Summary = $EventlistWidget->{data}[$Selected][1];
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my %TimeHash = (
		EventYear => $EventYear,
		EventMonth => $EventMonth,
		EventDay => $EventDay,
		OldEventYear => $EventYear,
		OldEventMonth => $EventMonth,
		OldEventDay => $EventDay,
		OldEventTime => $Time,
	);
		
	# Create the main window with the appropriate OK/Cancel buttons and the event frame
	my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton);

	my $Type = GetEventListType();

	if ($Type eq 'normal') {
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		# NORMAL EVENT
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		if(CalendarDefined($EventYear,$EventMonth,$EventDay,$Time)) {
			($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Editing an event"), $Gettext->get('Editing an event on the %s. %s %s'), 'gtk-ok');

			# Create the widgets for the normal event selection
			my ($NE_MainWidget, $NE_HourSpinner, $NE_MinuteSpinner, $NE_AMPM, $NE_SummaryWidget, $NE_DetailsWidget) = NormalEventWindow($Time, $OKButton, $VBox_HBoxContainer, $Window);
	
			$OKButton->signal_connect('clicked' => sub {
					NormalEvent_OK($Window, $NE_HourSpinner, $NE_MinuteSpinner, $NE_AMPM, $NE_SummaryWidget, $NE_DetailsWidget, \%TimeHash, 1);
			});
		
			# Show the default widget (Normal event)
			$NE_MainWidget->show();
		} else {
			DPIntWarn("BUG!: EditEvent: Unable to edit $Type event: $EventYear/$EventMonth/$EventDay/$Time. Please report this");
			$MainWindow->set_sensitive(1);
			return(0);
		}
	} elsif ($Type eq 'bday') {
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		# BIRTHDAY EVENT
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Editing a birthday"), $Gettext->get('Editing a birthday on the %s. %s %s'), 'gtk-ok');
		
		$Summary = GetRealBirthdayName($Summary);
		$TimeHash{OldEventSummary} = $Summary;
		if(BirthdayDefined($EventMonth, $EventDay, $Summary)) {
			# Create the widgets for the birthday event selection
			my ($BE_MainWidget, $BE_NameWidget) = BirthdayEventWindow($Summary, $VBox_HBoxContainer, $Window);
			$BE_MainWidget->show();
			$OKButton->signal_connect('clicked' => sub { BirthdayEvent_OK ($Window, $BE_NameWidget, \%TimeHash, 1)});
		} else {
			DPIntWarn("BUG!: EditEvent: Unable to edit $Type event: $EventMonth/$EventDay/$Summary. Please report this");
			$MainWindow->set_sensitive(1);
			return(0);
		}
			
	} elsif ($Type eq 'holiday') {
		DPInfo(sprintf($Gettext->get("This is a predefined \"holiday\" event. This event can not be edited directly from within day planner. In order to change these events use a text editor and edit the file %s."), $HolidayFile));
		$MainWindow->set_sensitive(1);
		return(1);
	} else {
		DPIntWarn("BUG!: EditEvent: \$Type contained invalid value: $Type");
		$MainWindow->set_sensitive(1);
		return(0);
	}
	
	$Tooltips->set_tip($CancelButton, $Gettext->get("Discard changes"));
	$Tooltips->set_tip($OKButton, $Gettext->get("Accept changes"));
			
	# Show the window
	$Window->show();
}

# Purpose: Create the widgets for editing a normal(events.dpd) event (%CalendarContents)
# Usage: my ($NormalEventWidget, $HourSpinner, $MinuteSpinner, $SummaryWidget, $DetailsWidget) = NormalEventWindow(TIME, OK_BUTTON, VBOX_WIDGET, MAIN_WINDOW_WIDGET);
#
# TIME is the time you're editing or undef
# OK_BUTTON is the OK button widget to attach to
# VBOX_WIDGET is the widget you want to pack our table into
# MAIN_WINDOW_WIDGET is the main window it will live inside
sub NormalEventWindow {
	# ==================================================================
	# INITIALIZE
	# ==================================================================
	my ($EventTime, $OKButton, $ParentVBox, $MyWindow) = @_;

	my $IsEditing = 0;
	
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my ($EventSummary, $EventFulltext);
	my ($OldEventYear, $OldEventMonth,$OldEventDay,$OldEventTime);
	
	# Check if the event is already defined, if it is then we assume that we're editing
	if(CalendarDefined($EventYear,$EventMonth,$EventDay,$EventTime)) {
		# We assume these two aren't empty. This will need to change if another part becomes obligatory
		$EventSummary = $CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime}{"summary"};
		$EventFulltext = $CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime}{"fulltext"};
		($OldEventYear, $OldEventMonth,$OldEventDay,$OldEventTime) = ($EventYear,$EventMonth,$EventDay,$EventTime);
		$IsEditing = 1;
	}

	if ($EventTime eq 'NULL') {
		$EventTime = "00:00";
	}

	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	
	# Create our main vbox
	my $MainVBox = Gtk2::VBox->new();
	$ParentVBox->pack_start($MainVBox,0,0,0);
	
	# Create the table inside the frame
	my $ContentTable = Gtk2::Table->new(2,2);
	$ContentTable->show();
	$MainVBox->pack_start($ContentTable,1,1,0);
	
	# ==================================================================
	# ADD THE TIME/SUMMARY BOXES
	# ==================================================================
	
	# Create the time label
	my $TimeLabel = Gtk2::Label->new($Gettext->get('Time:'));
	$TimeLabel->show();
	$ContentTable->attach_defaults($TimeLabel, 0,1,0,1);
	
	# Time entry box
	my ($HourSpinner, $MinuteSpinner, $TimeHBox, $AMPM) = TimeSelection($EventTime);
	# Attach them to our main widget
	$ContentTable->attach_defaults($TimeHBox, 1,2,0,1);
	
	# Create the summary label
	my $SummaryLabel = Gtk2::Label->new($Gettext->get('Description:'));
	$SummaryLabel->show();
	$ContentTable->attach_defaults($SummaryLabel, 0,1,1,2);

	# Create the summary entry box
	my $SummaryEntry = Gtk2::Entry->new();
	if (defined($EventSummary) and length($EventSummary)) {
		$SummaryEntry->set_text($EventSummary);
	}
	$SummaryEntry->set_activates_default(1);
	$SummaryEntry->show();
	$ContentTable->attach_defaults($SummaryEntry, 1,2,1,2);
	$Tooltips->set_tip($SummaryEntry, $Gettext->get("Enter a description of the event here"));
	
	# ==================================================================
	# ADD THE EXTENDED ENTRY
	# ==================================================================
	my $FulltextWindow;
	
	my $FT_Expander = Gtk2::Expander->new($Gettext->get("Details"));
	$MainVBox->pack_start($FT_Expander,0,0,0);
	$FT_Expander->show();
	if ($UserConfig{EditorVerboseDefault}) {
		$FT_Expander->set_expanded(1);
	}
	$Tooltips->set_tip($FT_Expander, $Gettext->get("Additional information"));
	
	# Add the extended entry box
	my $FulltextEntry = Gtk2::TextView->new();
	$FulltextEntry->set_editable(1);
	$FulltextEntry->set_wrap_mode("word-char");
	$FulltextEntry->show();
	# Add text to it if needed
	if (defined($EventFulltext) and $EventFulltext =~ /\S/) {
		my $AddEventBuffer = Gtk2::TextBuffer->new();
		$AddEventBuffer->set_text($EventFulltext);
		$FulltextEntry->set_buffer($AddEventBuffer);
		$FT_Expander->set_expanded(1);
	}

	$FulltextWindow = Gtk2::ScrolledWindow->new;
	$FulltextWindow->set_policy('automatic', 'automatic');
	$FulltextWindow->add($FulltextEntry);
	$FulltextWindow->show();
	$FT_Expander->add($FulltextWindow);
	
	return($MainVBox, $HourSpinner, $MinuteSpinner, $AMPM, $SummaryEntry, $FulltextEntry);
}

# Purpose: Create the widgets for editing a birthday(birthdays.dpd) event (%BirthdayContents)
# Usage: my ($BirthdayEventWidget, $SummaryWidget) = NormalEventWindow(SUMMARY, VBOX_WIDGET, MAIN_WINDOW_WIDGET);
#
# SUMMARY is the birthday you're editing or undef
# VBOX_WIDGET is the widget you want to pack our widgets into
# MAIN_WINDOW_WIDGET is the main window it will live inside
sub BirthdayEventWindow {
	# ==================================================================
	# INITIALIZE
	# ==================================================================
	my ($EventSummary, $ParentVBox, $MyWindow) = @_;

	my $IsEditing = 0;
	
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my ($OldEventMonth,$OldEventDay,$OldEventSummary);
	
	# Check if the event is already defined, if it is then we assume that we're editing
	if(defined($EventSummary) and length($EventSummary)) {
		($OldEventMonth,$OldEventDay,$OldEventSummary) = ($EventMonth,$EventDay,$EventSummary);
		$IsEditing = 1;
	}
	
	# Create our main vbox
	my $MainVBox = Gtk2::VBox->new();
	$ParentVBox->pack_start($MainVBox,0,0,0);
	
	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	
	# Create the table inside the frame
	my $ContentTable = Gtk2::Table->new(2,2);
	$ContentTable->show();
	$MainVBox->pack_start($ContentTable,1,1,0);
	
	# ==================================================================
	# ADD THE TIME/SUMMARY BOXES
	# ==================================================================
	
	# Create the summary label
	my $SummaryLabel = Gtk2::Label->new($Gettext->get('Name:'));
	$SummaryLabel->show();
	$ContentTable->attach_defaults($SummaryLabel, 0,1,1,2);

	# Create the summary entry box
	my $SummaryEntry = Gtk2::Entry->new();
	if (defined($EventSummary) and length($EventSummary)) {
		$SummaryEntry->set_text($EventSummary);
	}
	$SummaryEntry->set_activates_default(1);
	$SummaryEntry->show();
	$ContentTable->attach_defaults($SummaryEntry, 1,2,1,2);
	$Tooltips->set_tip($SummaryEntry, $Gettext->get("Enter the name of the person whose birthday it is here"));
	
	return($MainVBox, $SummaryEntry);
}

# Purpose: Handle the OK button for the Normal event widget
# Usage: $OKButton->signal_connect('clicked' => sub { NormalEvent_OK($MainWindow, $HourSpinner, $MinuteSpinner, $SummaryEntry, $FulltextEntry, \%TimeHash, IS_EDITING)});
#
# IS_EDITING is either true or false, false when it's a new one being added, true when it's an
# old one being edited
sub NormalEvent_OK {
	my ($MyWindow, $HourSpinner, $MinuteSpinner, $AMPM, $SummaryEntry, $FulltextEntry, $TimeHash, $IsEditing) = @_;
	my $Error = 0;
	
	# Get the contents
	my $Time = GetTimeFromWidgets($HourSpinner,$MinuteSpinner, $AMPM);
	my $Summary = $SummaryEntry->get_text;
	my $FulltextBuff = $FulltextEntry->get_buffer;
	my $Fulltext = $FulltextBuff->get_text($FulltextBuff->get_bounds,1);

	# Get variables from the TimeHash
	my $EventYear = ${$TimeHash}{EventYear};
	my $EventMonth = ${$TimeHash}{EventMonth};
	my $EventDay = ${$TimeHash}{EventDay};
	my $OldEventYear = ${$TimeHash}{OldEventYear};
	my $OldEventMonth = ${$TimeHash}{OldEventMonth};
	my $OldEventDay = ${$TimeHash}{OldEventDay};
	my $OldEventTime = ${$TimeHash}{OldEventTime};
	
	# Make sure it's not a dupe (that would end up overwriting data)
	if ($IsEditing) {
		if (defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time})) {
			unless ($EventYear eq $OldEventYear and $EventMonth eq $OldEventMonth  and $EventDay eq $OldEventDay and $Time eq $OldEventTime) {
				DPError(sprintf($Gettext->get("There is already an event at %s on %s %s. Please select another time for this event."), $Time, $EventDay, $MonthNames{$EventMonth}));
				$Error = 1;
			}
		}
	} else {
		if (defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time})) {
				DPError(sprintf($Gettext->get("There is already an event at %s on %s %s. Please select another time for this event."), $Time, $EventDay, $MonthNames{$EventMonth}));
				$Error = 1;
			}
	}
	unless ($Summary) {
		DPError($Gettext->get("There is no summary for this event. Please enter a summary."));
		$Error = 1;
	}
	# We don't do this if an error occurred
	unless ($Error) {
		# Delete old hash if needed
		if($IsEditing) {
			CalendarDelete($OldEventYear,$OldEventMonth,$OldEventDay,$OldEventTime);
		}
		# Add them to the hash
		$CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time}{'summary'} = $Summary;
		$CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time}{'fulltext'} = $Fulltext;
		# Call UpdatedData to tell Day planner to save the data and redraw widgets
		UpdatedData();
		# Destroy our window, it will get the signal and do anything it needs to
		$MyWindow->destroy;
		$MainWindow->set_sensitive(1);
	}
}

# Purpose: Handle the OK button for the birthday event widget
# Usage: $OKButton->signal_connect('clicked' => sub { BirthdayEvent_OK ($MainWindow, $SummaryEntry, \%TimeHash, IS_EDITING)});
#
# IS_EDITING is either true or false, false when it's a new one being added, true when it's an
# old one being edited
sub BirthdayEvent_OK {
	my ($MyWindow, $SummaryEntry, $TimeHash, $IsEditing) = @_;
	my $Error = 0;
	
	# Get the contents
	my $Summary = $SummaryEntry->get_text;

	# Get variables from the TimeHash
	my $EventMonth = ${$TimeHash}{EventMonth};
	my $EventDay = ${$TimeHash}{EventDay};
	my $OldEventMonth = ${$TimeHash}{OldEventMonth};
	my $OldEventDay = ${$TimeHash}{OldEventDay};
	my $OldEventSummary = ${$TimeHash}{OldEventSummary};
	
	# Make sure it's not a dupe (that would end up overwriting data)
	if ($IsEditing) {
		if (defined($BirthdayContents{$EventMonth}{$EventDay}{$Summary})) {
			unless ($EventMonth eq $OldEventMonth  and $EventDay eq $OldEventDay and $Summary eq $OldEventSummary) {
				DPError($Gettext->get(sprintf("A Birthday already exists for \"%s\" on %s %s", $Summary, $EventDay, $MonthNames{$EventMonth})));
				$Error = 1;
			}
		}
	} else {
		if (defined($BirthdayContents{$EventMonth}{$EventDay}{$Summary})) {
			DPError($Gettext->get(sprintf("A Birthday already exists for \"%s\" on %s %s", $Summary, $EventDay, $MonthNames{$EventMonth})));
			$Error = 1;
		}
	}
	unless ($Summary) {
		DPError($Gettext->get("A name is required to add a birthday"));
		$Error = 1;
	}
	# We don't do this if an error occurred
	unless ($Error) {
		# Delete old hash if needed
		if($IsEditing) {
			BirthdayDelete($OldEventMonth,$OldEventDay,$OldEventSummary);
		}
		# Add them to the hash
		$BirthdayContents{$EventMonth}{$EventDay}{$Summary} = 1;
		# Call UpdatedData to tell Day planner to save the data and redraw widgets
		UpdatedData();
		# Destroy our window, it will get the signal and do anything it needs to
		$MyWindow->destroy;
		$MainWindow->set_sensitive(1);
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# USER DIALOGS

# Purpose: Display the about dialog
# Usage: AboutBox();
sub AboutBox {
	$MainWindow->set_sensitive(0);
	my $AboutDialog = Gtk2::AboutDialog->new;
	$AboutDialog->set_transient_for($MainWindow);
	$AboutDialog->set_position('center-on-parent');
	$AboutDialog->set_authors("Eskild Hustvedt <zerodogg AT skolelinux DOT no>");
	$AboutDialog->set_artists("Jason Holland <jasonholland AT rawsoftware DOT com>");
	$AboutDialog->set_copyright("Copyright (C) Eskild Hustvedt 2006");
	$AboutDialog->set_website("http://home.gna.org/dayplanner/");
	$AboutDialog->set_name($Gettext->get("Day planner"));
	$AboutDialog->set_version($Version);
	# GPL summary, should never be marked as translateable
	$AboutDialog->set_license("Day planner is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nDay planner is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with day planner; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.");
	# Logo
	my $LogoImage = DetectImage("dayplanner-about.png","dayplanner_48.png","dayplanner_24.png", "dayplanner_16.png", "dayplanner_HC48.png","dayplanner_HC24.png", "dayplanner_HC16.png", "dayplanner.png");
	if ($LogoImage) {
		my $PixBuf = Gtk2::Gdk::Pixbuf->new_from_file($LogoImage);
		$AboutDialog->set_logo($PixBuf);
	}
	# Translator credits
	unless ($Gettext->get("THE NAMES OF THE TRANSLATORS") eq "THE NAMES OF THE TRANSLATORS") {
		$AboutDialog->set_translator_credits($Gettext->get("THE NAMES OF THE TRANSLATORS"));
	}
	$AboutDialog->run;
	$AboutDialog->destroy();
	$MainWindow->set_sensitive(1);
}

# Purpose: Draw the preferences window and allow the user to set different
#  configuration options
# Usage: PreferencesWindow();
sub PreferencesWindow {
	$MainWindow->set_sensitive(0);
	my $PreferencesWindow = Gtk2::Window->new();
	$PreferencesWindow->set_modal(1);
	$PreferencesWindow->set_transient_for($MainWindow);
	$PreferencesWindow->set_position('center-on-parent');
	$PreferencesWindow->set_title($Gettext->get("Preferences"));
	$PreferencesWindow->set_resizable(0);
	$PreferencesWindow->set_border_width(12);
	$PreferencesWindow->set_skip_taskbar_hint(1);
	$PreferencesWindow->set_skip_pager_hint(1);
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();

	# Handle closing
	$PreferencesWindow->signal_connect("destroy" => sub { 
			$MainWindow->set_sensitive(1);
			SaveDefaultConfig();
			});
	
	# Creat the vbox
	my $Config_VBox = Gtk2::VBox->new();
	$Config_VBox->show();
	$PreferencesWindow->add($Config_VBox);
	
	# ==================================================================
	# GENERAL
	# ==================================================================
	
	# Create the primary vbox
	my $General_VBox = Gtk2::VBox->new();
	$General_VBox->show();
	$Config_VBox->pack_start($General_VBox,0,0,0);
	
	my $UI_Label = Gtk2::Label->new("<b>" . $Gettext->get("Interface") . "</b>");
	$UI_Label->set_use_markup(1);
	$UI_Label->set_alignment(0,1);
	$General_VBox->pack_start($UI_Label,0,0,0);
	$UI_Label->show();

	# EDITOR VERBOSE DEFAULT
	my $EDVDefaultCheckbox = Gtk2::CheckButton->new_with_label(sprintf($Gettext->get("Expand \"%s\" by default"), $Gettext->get("Details")));
	$General_VBox->pack_start($EDVDefaultCheckbox,0,0,0);
	$EDVDefaultCheckbox->show();
	if ($UserConfig{EditorVerboseDefault}) {
		$EDVDefaultCheckbox->set_active(1);
	}
	$EDVDefaultCheckbox->signal_connect( "toggled" => sub {
			if ($EDVDefaultCheckbox->get_active) {
				$UserConfig{EditorVerboseDefault} = 1;
			} else {
				$UserConfig{EditorVerboseDefault} = 0;
			}
		});
	
	$Tooltips->set_tip($EDVDefaultCheckbox, sprintf($Gettext->get("Check this if you want the \"%s\" to be expanded by default in the add and edit event dialog"), $Gettext->get("Details")));

	# ==================================================================
	# EVENTS
	# ==================================================================
	
	# A simple hash we use to parse back and forth between the PreNotification
	# combo box and the config option itself
	my %PreNotificationParser = (
		0 => '10min',
		1 => '20min',
		2 => '30min',
		3 => '45min',
		4 => '1hr',
		5 => '2hrs',
		6 => '4hrs',
		7 => '6hrs',
		
		'10min' => 0,
		'20min' => 1,
		'30min' => 2,
		'45min' => 3,
		'1hr' => 4,
		'1hrs' => 4,
		'2hr' => 5,
		'2hrs' => 5,
		'4hr' => 6,
		'4hrs' => 6,
		'6hr' => 7,
		'6hrs' => 7,

		'default' => 3,
		'readable_default' => '45mins',
	);
	
	# Create the vbox
	my $Events_VBox = Gtk2::VBox->new();
	$Events_VBox->show();
	$Config_VBox->pack_start($Events_VBox,0,0,0);

	# The label
	my $Events_Label = Gtk2::Label->new("<b>" . $Gettext->get("General events") . "</b>");
	$Events_Label->set_use_markup(1);
	$Events_Label->set_alignment(0,1);
	$Events_VBox->pack_start($Events_Label,0,0,0);
	$Events_Label->show();

	# If the reminder should autostart on login or not
	my $AutostartReminder_Checkbox = Gtk2::CheckButton->new_with_label($Gettext->get("Start the day planner reminder automatically when logging in"));
	$AutostartReminder_Checkbox->show();
	$Events_VBox->pack_start($AutostartReminder_Checkbox,0,0,0);
	$AutostartReminder_Checkbox->set_active(1) if $InternalConfig{AddedAutostart};
	$AutostartReminder_Checkbox->signal_connect('toggled' => sub {
			if($AutostartReminder_Checkbox->get_active) {
				DP_AddAutostart();
			} else {
				unless(DP_RemoveAutostart()) {
					$AutostartReminder_Checkbox->set_active(1);
				}
			}
		});
	
	# The main checkbox that enables/disables the rest of the page
	my $Events_EnabledCheckbox = Gtk2::CheckButton->new_with_label($Gettext->get("Use notifications before events"));
	$Events_EnabledCheckbox->show();
	$Events_VBox->pack_start($Events_EnabledCheckbox,0,0,0);

	# The widgets that selects when the user wants to be notified
	# The HBox
	my $TimeSel_HBox = Gtk2::HBox->new();
	$Events_VBox->pack_start($TimeSel_HBox,0,0,0);
	$TimeSel_HBox->show();
	# The label
	my $TimeSel_Label = Gtk2::Label->new($Gettext->get('Time before the event to display the notification') . ': ');
	$TimeSel_Label->show();
	$TimeSel_HBox->pack_start($TimeSel_Label,0,0,0);
	# The combo box
	my $TimeSel_Combo = Gtk2::ComboBox->new_text();
	$TimeSel_Combo->insert_text(0, sprintf($Gettext->get("%s minutes"),"10"));
	$TimeSel_Combo->insert_text(1, sprintf($Gettext->get("%s minutes"),"20"));
	$TimeSel_Combo->insert_text(2, sprintf($Gettext->get("%s minutes"),"30"));
	$TimeSel_Combo->insert_text(3, sprintf($Gettext->get("%s minutes"),"45"));
	$TimeSel_Combo->insert_text(4, sprintf($Gettext->get("%s hour"),"1"));
	$TimeSel_Combo->insert_text(5, sprintf($Gettext->get("%s hours"),"2"));
	$TimeSel_Combo->insert_text(6, sprintf($Gettext->get("%s hours"),"4"));
	$TimeSel_Combo->insert_text(7, sprintf($Gettext->get("%s hours"),"6"));
	# Set the value
	if($UserConfig{Events_NotifyPre} eq "0") {
		$TimeSel_Combo->set_active(3);
	} elsif (defined($PreNotificationParser{$UserConfig{Events_NotifyPre}})) {
		$TimeSel_Combo->set_active($PreNotificationParser{$UserConfig{Events_NotifyPre}});
	} else {
		$TimeSel_Combo->set_active($PreNotificationParser{'default'});
	}
	$TimeSel_Combo->show();
	$TimeSel_HBox->pack_start($TimeSel_Combo,0,0,0);
	# Register the changed signal
	$TimeSel_Combo->signal_connect('changed' => sub {
				$UserConfig{Events_NotifyPre} = $PreNotificationParser{$TimeSel_Combo->get_active};
			});
	
	# If the user wants to be notified in advance
	my $NotifyAdvance_CheckBox = Gtk2::CheckButton->new_with_label($Gettext->get("Remind one day in advance"));
	$NotifyAdvance_CheckBox->show();
	$Events_VBox->pack_start($NotifyAdvance_CheckBox,0,0,0);
	$NotifyAdvance_CheckBox->signal_connect('toggled' => sub {
			$UserConfig{Events_DayNotify} = $NotifyAdvance_CheckBox->get_active();
		});
	if($UserConfig{Events_DayNotify}) {
		$NotifyAdvance_CheckBox->set_active(1);
	}
	
	# This needs to be at the bottom so that we can sensitiveize or not the rest of the dialog
	$Events_EnabledCheckbox->signal_connect('toggled' => sub {
			if($Events_EnabledCheckbox->get_active) {
				$TimeSel_Combo->set_sensitive(1);
				$TimeSel_Label->set_sensitive(1);
				$NotifyAdvance_CheckBox->set_sensitive(1);
				$UserConfig{Events_NotifyPre} = $PreNotificationParser{$TimeSel_Combo->get_active};
			} else {
				$TimeSel_Combo->set_sensitive(0);
				$TimeSel_Label->set_sensitive(0);
				$NotifyAdvance_CheckBox->set_sensitive(0);
				$UserConfig{Events_NotifyPre} = 0;
			}
		});
	if($UserConfig{Events_NotifyPre}) {
		$Events_EnabledCheckbox->set_active(1);
	} else {
		$Events_EnabledCheckbox->set_active(0);
		$TimeSel_Combo->set_sensitive(0);
		$TimeSel_Label->set_sensitive(0);
		$NotifyAdvance_CheckBox->set_sensitive(0);
	}
	
	# ==================================================================
	# FINALIZE WINDOW
	# ==================================================================
	# Add the buttons
	my $ButtonHBox = Gtk2::HBox->new();
	$ButtonHBox->show();
	$Config_VBox->pack_start($ButtonHBox,0,0,0);

	my $CloseButton = Gtk2::Button->new_from_stock('gtk-close');
	$CloseButton->signal_connect("clicked" => sub { 
			$PreferencesWindow->destroy;
		});
	$CloseButton->show();
	$ButtonHBox->pack_end($CloseButton,0,0,0);

	# Show the config window
	$PreferencesWindow->show();
}

# MAIN WINDOW

# Purpose: Draw the eventlist on the currently selected date in the calendar
# Usage: DrawEventlist();
sub DrawEventlist {
	my $Year = $CalendarWidget->year;
	my $Month = $CalendarWidget->month;$Month++;
	my $Day = $CalendarWidget->selected_day;
	
	# New eventlist so make the toolbar edit button and edit/delete menu entries insensitive
	$ToolbarEditButton->set_sensitive(0);
	$MenuEditEntry->set_sensitive(0);
	$MenuDeleteEntry->set_sensitive(0);

	# Create the widget if needed
	unless ($EventlistWidget) {
		# Greate the pop-up on right-click
		my $PopupWidget = Gtk2::Menu->new();
		my $delete = Gtk2::ImageMenuItem->new_from_stock('gtk-delete');
		$delete->show();
		$delete->signal_connect('activate' => \&DeleteEvent);
		my $edit = Gtk2::ImageMenuItem->new_from_stock('gtk-edit');
		$edit->show();
		$edit->signal_connect('activate' => \&EditEvent);
		$PopupWidget->append($edit);
		$PopupWidget->append($delete);
		$PopupWidget->show();

		# Create the widget and set up signal handlers
		$EventlistWidget = Gtk2::SimpleList->new (
			$Gettext->get("Time") => 'text',
			$Gettext->get("Event") => 'text',
		);
		$EventlistWidget->set_rules_hint(1);
		$EventlistWidget->signal_connect("row_activated" => \&EditEvent);
		$EventlistWin->add($EventlistWidget);
		# Handle making the toolbar edit button sensitive
		$EventlistWidget->signal_connect('focus-in-event' => sub {
			my $Selected = [$EventlistWidget->get_selected_indices]->[0];
			# If there is something in that data array then there is something selected on focus-in-event
			if(@{$EventlistWidget->{data}}) {
				$ToolbarEditButton->set_sensitive(1);
				$MenuEditEntry->set_sensitive(1);
				$MenuDeleteEntry->set_sensitive(1);
			}
		});
		$EventlistWidget->signal_connect('button-release-event' => sub {
				my($widget,$event) = @_;
				my $button = $event->button;
				if($button == 3) {
					my($self, $event) = @_;
					my ($path, $column, $cell_x, $cell_y) = $EventlistWidget->get_path_at_pos ($event->x, $event->y);
					if(scalar($widget->get_selected_indices) > 0) {
						if(defined($path)) {
							$PopupWidget->popup(undef, undef, undef, undef, 0, 0);
						}
					}
				}
			});
	} else {
		# Remove data if needed
		@{$EventlistWidget->{data}} = ();
	}
	# Main calendar contents
	if (defined($CalendarContents{$Year}) and defined($CalendarContents{$Year}{$Month}) and defined($CalendarContents{$Year}{$Month}{$Day})) {
		foreach my $Time (sort keys %{$CalendarContents{$Year}{$Month}{$Day}}) {
			unless (defined($CalendarContents{$Year}{$Month}{$Day}{$Time}{"summary"})) {
				DPIntWarn("Found no summary for entry: $Time");
			} else {
				push (@{$EventlistWidget->{data}}, [AMPM_From24($Time), $CalendarContents{$Year}{$Month}{$Day}{$Time}{"summary"}]);
			}
		}
	}
	if (defined($BirthdayContents{$Month}) and defined($BirthdayContents{$Month}{$Day})) {
		foreach my $Birthday (sort keys %{$BirthdayContents{$Month}{$Day}}) {
			push (@{$EventlistWidget->{data}}, ["", sprintf($Gettext->get("%s's birthday"), $Birthday)]);
		}
	}
	unless($Year > 2037) {
		unless($Year < 1970) {
			unless(defined($HolidayParser)) {
				$HolidayParser = Date::HolidayParser->new($HolidayFile);
			}
			unless(defined($Holidays{$Year})) {
					$Holidays{$Year} = $HolidayParser->get($Year);
			}
			if(defined($Holidays{$Year}) and defined($Holidays{$Year}->{$Month}) and defined($Holidays{$Year}->{$Month}{$Day})) {
				foreach my $CurrHoliday (keys(%{$Holidays{$Year}->{$Month}{$Day}})) {
					push(@{$EventlistWidget->{data}}, ["", $CurrHoliday]);
				}
			}
		}

	}

	$EventlistWidget->show();
}

# Purpose: Draw the main window
# Usage: DrawMainWindow();
sub DrawMainWindow {
	# ==================================================================
	# BUILD THE MAIN WINDOW
	# ==================================================================
	# Create the main window widget
	$MainWindow = Gtk2::Window->new('toplevel');
	$MainWindow->set_title($Gettext->get("Day planner"));
	$MainWindow->set_default_size ($InternalConfig{MainWin_Width},$InternalConfig{MainWin_Height});
	$MainWindow->maximize if ($InternalConfig{MainWin_Maximized});

	# Set the icon
	my $MainWindowIcon = DetectImage("dayplanner_48.png","dayplanner_24.png", "dayplanner_16.png", "dayplanner_HC48.png","dayplanner_HC24.png", "dayplanner_HC16.png", "dayplanner.png");
	if ($MainWindowIcon) {
		$MainWindow->set_default_icon_from_file($MainWindowIcon);
	}

	# Make it handle closing
	$MainWindow->signal_connect("destroy" => \&QuitSub);
	$MainWindow->signal_connect("delete-event" => \&QuitSub);

	# Handle saving maximized state
	$MainWindow->signal_connect(window_state_event => sub {
		my ($widget, $event) = @_;
		$InternalConfig{MainWin_Maximized} = ($event->new_window_state & 'maximized');
	});
		

	# Create the primary VBox for use inside it
	my $PrimaryWindowVBox = Gtk2::VBox->new();
	$PrimaryWindowVBox->show();
	$MainWindow->add($PrimaryWindowVBox);

	# ==================================================================
	# MENUBAR
	# ==================================================================
	
	# Get stock values
	my $EditStock = Gtk2::Stock->lookup('gtk-edit')->{label};
	my $QuitStock = Gtk2::Stock->lookup('gtk-quit')->{label};
	my $PrefsStock = Gtk2::Stock->lookup('gtk-preferences')->{label};
	my $AboutStock = Gtk2::Stock->lookup('gtk-about')->{label};
	my $HelpStock = Gtk2::Stock->lookup('gtk-help')->{label};
	my $DeleteStock = Gtk2::Stock->lookup('gtk-delete')->{label};

	# The menu items
	my @MenuItems = (
		# Calendar menu
		[ "/" . $Gettext->get("_Calendar"),						undef,			undef,			0,	"<Branch>"],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Import"),		"",		\&ImportData,		1,	"<StockItem>",	'gtk-open'],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Export"),		undef,		\&ExportData,		1,	"<StockItem>",	'gtk-save-as'],
		[ "/" . $Gettext->get("_Calendar") . "/sep",					undef,			undef,			2,	'<Separator>'],
		[ "/" . $Gettext->get("_Calendar") . "/$QuitStock",		"<control>Q",		\&QuitSub,		3,	"<StockItem>",	'gtk-quit'],
		# Edit menu
		[ "/$EditStock", undef,			undef,			0,	"<Branch>"],
		[ "/$EditStock/" . $Gettext->get("_Add an event"),		"<control>A",		\&AddEvent,		1,	'<StockItem>',	'gtk-add' ],
		[ "/$EditStock/" . $Gettext->get("_Edit this event"),	"<control>E",		\&EditEvent,		2,	'<StockItem>',	'gtk-edit' ],
		[ "/$EditStock/" . $Gettext->get("_Delete this event"),	"<control>D",		\&DeleteEvent,		3,	'<StockItem>',	'gtk-delete' ],
		[ "/$EditStock/sep",					undef,			undef,			4,	'<Separator>'],
		[ "/$EditStock/$PrefsStock" , undef,			\&PreferencesWindow,		1, 	'<StockItem>', 'gtk-preferences' ],
		# Help menu
		[ "/$HelpStock",						undef,			undef,			0,	"<Branch>" ],
		[ "/$HelpStock/$AboutStock" ,undef,			\&AboutBox,		0,	'<StockItem>',	'gtk-about'],
	);
	# The accelgroup to use for the menuitems
	my $Menu_AccelGroup = Gtk2::AccelGroup->new;
	$MainWindow->add_accel_group($Menu_AccelGroup);
	# The item factory (menubar) itself
	my $Menu_ItemFactory = Gtk2::ItemFactory->new('Gtk2::MenuBar', '<main>', $Menu_AccelGroup);
	# Tell the item factory to use the items defined in @MenuItems
	$Menu_ItemFactory->create_items (undef, @MenuItems);
	# Pack it onto the vbox
	$PrimaryWindowVBox->pack_start($Menu_ItemFactory->get_widget("<main>"), 0, 0, 0);
	# Show it
	$Menu_ItemFactory->get_widget("<main>")->show();
	
	# Create two widget objects for the edit/delete menu entries
	my $Get = "/$EditStock/" . $Gettext->get("_Edit this event");
	$Get =~ s/_//g;
	$MenuEditEntry = $Menu_ItemFactory->get_widget($Get);

	$Get = "/$EditStock/" . $Gettext->get("_Delete this event");
	$Get =~ s/_//g;
	$MenuDeleteEntry = $Menu_ItemFactory->get_widget($Get);

	# ==================================================================
	# TOOLBAR
	# ==================================================================
	$Toolbar = Gtk2::Toolbar->new();
	$PrimaryWindowVBox->pack_start($Toolbar,0,0,0);
	$Toolbar->show();

	# Edit button
	$ToolbarEditButton = Gtk2::MenuToolButton->new_from_stock('gtk-edit');
	$ToolbarEditButton->signal_connect('clicked' => \&EditEvent);
	$Toolbar->insert($ToolbarEditButton,0);
	$ToolbarEditButton->show();

	my @EditMenuItems = (
		[ "/$DeleteStock",	undef,		\&DeleteEvent,		3,	'<StockItem>',	'gtk-delete' ],
	);
		
	my $EditMenuIF = Gtk2::ItemFactory->new ("Gtk2::Menu","<main>");
	$EditMenuIF->create_items (undef, @EditMenuItems);
	my $EditMenuWidget = $EditMenuIF->get_widget("<main>");
	$EditMenuWidget->show();
	$ToolbarEditButton->set_menu($EditMenuWidget);
	
	# Add button
	my $AddButton = Gtk2::ToolButton->new_from_stock('gtk-add');
	$AddButton->signal_connect("clicked" => \&AddEvent);
	$Toolbar->insert($AddButton,0);
	$AddButton->show();

	$Toolbar->get_nth_item(0)->set_is_important(1);
	$Toolbar->get_nth_item(1)->set_is_important(1);

	# ==================================================================
	# WORKING AREA
	# ==================================================================
	# Create the hbox which will contain the rest of the program
	$WorkingAreaHBox = Gtk2::HBox->new();
	$WorkingAreaHBox->show();
	# Add it to the primary VBox
	$PrimaryWindowVBox->pack_start($WorkingAreaHBox,1,1,0);
	
	# ==================================================================
	# THE RIGHT HAND AREA
	# ==================================================================
	
	# Create the vbox for use in it
	my $RightHandVBox = Gtk2::VBox->new();
	$WorkingAreaHBox->pack_end($RightHandVBox,0,0,0);
	$RightHandVBox->show();

	# CALENDAR
	# Create the calendar
	$CalendarWidget = Gtk2::Calendar->new;
	GetDate();
	SetActiveCalItems($curryear, $currmonth);
	$CalendarWidget->show();
	$CalendarWidget->display_options(['show-week-numbers', 'show-day-names','show-heading']);
	$currmonth--;
	# Work around a possible Gtk2::Calendar bug by explicitly setting the month/year combo
	$CalendarWidget->select_month($currmonth, $curryear);
	$RightHandVBox->pack_start($CalendarWidget,0,0,0);
	
	my $LastDay = Get_DateInfo($CalendarWidget);

	$CalendarWidget->signal_connect('prev-month' => \&CalendarChange);
	$CalendarWidget->signal_connect('next-month' => \&CalendarChange);
	$CalendarWidget->signal_connect('prev-year' => \&CalendarChange);
	$CalendarWidget->signal_connect('next-year' => \&CalendarChange);
	$CalendarWidget->signal_connect('day-selected' => sub {
			if(Get_DateInfo($CalendarWidget) eq $LastDay) {
				return;
			}
			$LastDay = Get_DateInfo($CalendarWidget);
			DrawEventlist();
		});

	# UPCOMING EVENTS
	# Create the scrolled window
	my $UpcomingEventsWindow = Gtk2::ScrolledWindow->new;
	$UpcomingEventsWindow->set_policy('automatic', 'automatic');
	$UpcomingEventsWindow->show();
	# Create the TextView and TextBuffer objects
	$UpcomingEventsWidget = Gtk2::TextView->new();
	$UpcomingEventsBuffer = Gtk2::TextBuffer->new();
	$UpcomingEventsWidget->set_buffer($UpcomingEventsBuffer);
	$UpcomingEventsWidget->set_editable(0);
	$UpcomingEventsWidget->set_wrap_mode("word");
	$UpcomingEventsWidget->show();
	$UpcomingEventsWindow->add($UpcomingEventsWidget);
	# Pack it onto the main window
	$RightHandVBox->pack_end($UpcomingEventsWindow,1,1,0);
	
	# ==================================================================
	# TASK LIST
	# ==================================================================
	
	# Add a window for use for it
	$EventlistWin = Gtk2::ScrolledWindow->new;
	$EventlistWin->set_policy('automatic', 'automatic');
	$WorkingAreaHBox->pack_start($EventlistWin,1,1,0);
	$EventlistWin->show();
	
	# Draw the initial eventlist
	DrawEventlist();
	
	# ==================================================================
	# FINALIZE AND DISPLAY
	# ==================================================================

	# Finally, show the window and rest in the main Gtk2 loop
	$MainWindow->show();
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initialization
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get commandline options
GetOptions (
	'help|h' => sub {
		print "Day planner version $Version\n\n";
		PrintHelp("-h","--help","Display this help screen and exit");
		PrintHelp("-v","--version", "Display version information and exit");
		PrintHelp("-t","--test","Use a seperate debug/ configuration directory");
		PrintHelp("", "--confdir", "Use the directory supplied as configuration directory");
		PrintHelp("-s", "--shutdaemon", "Shutdown the daemon when day planner is closed");
		PrintHelp("", "--exportical", "Export the day planner data in the iCalendar format");
		PrintHelp("", "", "to the filename supplied");
		PrintHelp("", "--exportdpf", "Export the day planner data in the day planner data");
		PrintHelp("", "", "format to the filename supplied");
		PrintHelp("", "--exporthtml", "Export the day planner data in the HTML format to the");
		PrintHelp("", "", "directory supplied");
		PrintHelp("", "--importical", "Import data from the iCalendar file specified");
		PrintHelp("", "--importdpf", "Import data from the day planner data file specified");
		PrintHelp("","--debuginfo", "Display information useful for debugging and exit");
		exit(0);
	},
	'version|v' => sub {
		print "Day planner version $Version\n";
		print "RCS revision: $RCSRev\n";
		exit(0);
	},
	'debuginfo' => sub {
		print "Day planner version $Version\n";
		print "RCS revision: $RCSRev\n";
		print "Gtk2 version ", join (".", Gtk2->GET_VERSION_INFO),"\n";
		printf "Perl version %vd\n", $^V;
		print "OS: ", GetDistVer(), "\n";
		exit(0);
	},
	'test|t' => sub {
		print "*** (Day Planner $Version) Running in test mode\n";
		$SaveToDir = "$ENV{HOME}/.dayplanner/debug";
	},
	'confdir=s' => sub {
		if (-e $_[1]) {
			unless (-d $_[1]) {
				die "$_[1] is not a directory\n";
			}
			unless (-w $_[1]) {
				die "$_[1] is not writeable\n";
			}
		}
		$SaveToDir = $_[1];
	},
	's|shutdaemon' => \$ShutdownDaemon,
	'exportical|exportics=s' => \&CLI_Export,
	'exportdpf=s' => \&CLI_Export,
	'exporthtml=s' => \&CLI_Export,
	'importical|importics=s' => \&CLI_Import,
	'importdpf=s' => \&CLI_Import,
) or die "Run $0 --help for more information\n";

my $Gtk2_Initialized = 0;

# If for some obscure reason HOME isn't set we can't continue
unless(defined($ENV{HOME}) and $ENV{HOME}) {
	Gtk2Init();
	DPError(sprintf($Gettext->get("The environment variable %s is not set! Unable to continue\n"), "HOME"));
	die(sprintf($Gettext->get("The environment variable %s is not set! Unable to continue\n"), "HOME"));
}
# The same goes for if HOME doesn't exist or isn't a directory
unless(-e $ENV{HOME} and -d $ENV{HOME}) {
	printf($Gettext->get("The home directory of the user %s doesn't exist at %s! Please verify that the environment variable %s is properly set. Unable to continue\n"),[getpwuid($<)]->[0], $ENV{HOME}, "HOME");
	Gtk2Init();
	DPError(sprintf($Gettext->get("The home directory of the user %s doesn't exist at %s! Please verify that the environment variable %s is properly set. Unable to continue\n"),[getpwuid($<)]->[0], $ENV{HOME}, "HOME"));
	die("\n");
}

Gtk2Init();
MainInit();
# Draw the main window
DrawMainWindow();
Gtk2->main_iteration while Gtk2->events_pending;
# Initialize the daemon
DaemonInit() or die();
# Connect to a DPS server and sync the local data with it if it's enabled
DPS_GUIPerform("GET");
# Add autostart if needed
unless(defined($InternalConfig{AddedAutostart}) and $InternalConfig{AddedAutostart} eq "1") {
	DP_AddAutostart();
	$InternalConfig{AddedAutostart} = 1;
}
# Set the redraw timer and populate the upcoming events widget
PopulateUpcomingEvents();
Set_DayChangeTimer();

my $Exception =  Glib->install_exception_handler(sub {
		DPError("An exception occurred. This reflects a bug in the program.\nPlease save the following exception text and report this problem to the day planner developers.\nNow some things may not work as expected\n\nException:\n $_[0]");
		1;
	});

# Rest in the Gtk2 main loop
Gtk2->main;
